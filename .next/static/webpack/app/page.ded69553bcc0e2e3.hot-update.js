"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/app/simulation/world.ts":
/*!*************************************!*\
  !*** ./src/app/simulation/world.ts ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DENSITIES: function() { return /* binding */ DENSITIES; },\n/* harmony export */   ELEMENT_COLORS: function() { return /* binding */ ELEMENT_COLORS; },\n/* harmony export */   ELEMENT_TYPE: function() { return /* binding */ ELEMENT_TYPE; },\n/* harmony export */   clear: function() { return /* binding */ clear; },\n/* harmony export */   getCellSize: function() { return /* binding */ getCellSize; },\n/* harmony export */   getGrid: function() { return /* binding */ getGrid; },\n/* harmony export */   init: function() { return /* binding */ init; },\n/* harmony export */   saveWorld: function() { return /* binding */ saveWorld; },\n/* harmony export */   setElement: function() { return /* binding */ setElement; },\n/* harmony export */   setWalls: function() { return /* binding */ setWalls; },\n/* harmony export */   update: function() { return /* binding */ update; }\n/* harmony export */ });\nconst ELEMENT_TYPE = {\n    EMPTY: 0,\n    WALL: 1,\n    SAND: 2,\n    WATER: 3,\n    PLANT: 4,\n    FIRE: 5,\n    LAVA: 6,\n    ACID: 7,\n    SMOKE: 8,\n    STONE: 9,\n    STONE_ASH: 10,\n    ASH: 11,\n    HOT_ASH: 12\n};\nconst ELEMENT_COLORS = {\n    [ELEMENT_TYPE.EMPTY]: \"#000000\",\n    [ELEMENT_TYPE.WALL]: \"#505050\",\n    [ELEMENT_TYPE.SAND]: \"#f0d9a5\",\n    [ELEMENT_TYPE.WATER]: \"#3498db\",\n    [ELEMENT_TYPE.PLANT]: \"#2ecc71\",\n    [ELEMENT_TYPE.FIRE]: \"#e74c3c\",\n    [ELEMENT_TYPE.LAVA]: \"#d35400\",\n    [ELEMENT_TYPE.ACID]: \"#9b59b6\",\n    [ELEMENT_TYPE.SMOKE]: \"#888888\",\n    [ELEMENT_TYPE.STONE]: \"#808080\",\n    [ELEMENT_TYPE.STONE_ASH]: \"#6b6b6b\",\n    [ELEMENT_TYPE.ASH]: \"#2b2b2b\",\n    [ELEMENT_TYPE.HOT_ASH]: \"#db4f27\"\n};\nconst DENSITIES = {\n    [ELEMENT_TYPE.EMPTY]: 0,\n    [ELEMENT_TYPE.SMOKE]: 1,\n    [ELEMENT_TYPE.FIRE]: 1,\n    [ELEMENT_TYPE.WATER]: 10,\n    [ELEMENT_TYPE.ACID]: 11,\n    [ELEMENT_TYPE.ASH]: 12,\n    [ELEMENT_TYPE.HOT_ASH]: 12,\n    [ELEMENT_TYPE.SAND]: 15,\n    [ELEMENT_TYPE.PLANT]: 20,\n    [ELEMENT_TYPE.STONE_ASH]: 22,\n    [ELEMENT_TYPE.LAVA]: 25,\n    [ELEMENT_TYPE.STONE]: 30,\n    [ELEMENT_TYPE.WALL]: Infinity\n};\nconst LOCAL_STORAGE_KEY = \"sandSimulationGrid\";\nconst CELL_SIZE = 5;\nlet width, height;\nlet grid;\nlet areWallsOn = true;\nconst setWalls = (enabled)=>{\n    areWallsOn = enabled;\n    const wallType = enabled ? ELEMENT_TYPE.WALL : ELEMENT_TYPE.EMPTY;\n    if (!grid) return;\n    for(let y = 0; y < height; y++){\n        if (grid[y]) {\n            grid[y][0] = wallType;\n            grid[y][width - 1] = wallType;\n        }\n    }\n    for(let x = 0; x < width; x++){\n        if (grid[0]) grid[0][x] = wallType;\n        if (grid[height - 1]) grid[height - 1][x] = wallType;\n    }\n};\nconst saveWorld = ()=>{\n    if (grid) {\n        localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(grid));\n    }\n};\nconst clear = ()=>{\n    for(let y = 0; y < height; y++){\n        for(let x = 0; x < width; x++){\n            grid[y][x] = ELEMENT_TYPE.EMPTY;\n        }\n    }\n    if (areWallsOn) {\n        setWalls(true);\n    }\n    localStorage.removeItem(LOCAL_STORAGE_KEY);\n};\nconst init = (canvasWidth, canvasHeight)=>{\n    width = Math.floor(canvasWidth / CELL_SIZE);\n    height = Math.floor(canvasHeight / CELL_SIZE);\n    const savedGrid = localStorage.getItem(LOCAL_STORAGE_KEY);\n    if (savedGrid) {\n        try {\n            const parsedGrid = JSON.parse(savedGrid);\n            if (parsedGrid && parsedGrid.length === height && parsedGrid[0].length === width) {\n                grid = parsedGrid;\n                return;\n            }\n        } catch (e) {\n            console.error(\"Failed to parse saved grid:\", e);\n        }\n    }\n    grid = Array(height).fill(0).map(()=>Array(width).fill(ELEMENT_TYPE.EMPTY));\n    setWalls(areWallsOn);\n};\nconst getGrid = ()=>grid;\nconst getCellSize = ()=>CELL_SIZE;\nconst setElement = (x, y, elementType, brushSize)=>{\n    const radius = Math.floor(brushSize / CELL_SIZE / 2);\n    for(let i = -radius; i <= radius; i++){\n        for(let j = -radius; j <= radius; j++){\n            if (i * i + j * j <= radius * radius) {\n                const newX = x + i;\n                const newY = y + j;\n                if (newX >= 0 && newX < width && newY >= 0 && newY < height) {\n                    if (grid[newY][newX] === ELEMENT_TYPE.EMPTY || elementType === ELEMENT_TYPE.EMPTY) {\n                        grid[newY][newX] = elementType;\n                    }\n                }\n            }\n        }\n    }\n};\nconst move = (x1, y1, x2, y2)=>{\n    const temp = grid[y1][x1];\n    grid[y1][x1] = grid[y2][x2];\n    grid[y2][x2] = temp;\n};\nconst isWithinBounds = (x, y)=>{\n    return y >= 0 && y < height && x >= 0 && x < width;\n};\nconst isEmpty = (x, y)=>{\n    return isWithinBounds(x, y) && grid[y][x] === ELEMENT_TYPE.EMPTY;\n};\nconst is = (x, y, elementType)=>{\n    return isWithinBounds(x, y) && grid[y][x] === elementType;\n};\nconst set = (x, y, elementType)=>{\n    if (isWithinBounds(x, y)) {\n        grid[y][x] = elementType;\n    }\n};\nconst update = ()=>{\n    const updatedPositions = new Set();\n    const updateElement = (x, y)=>{\n        const pos = \"\".concat(x, \",\").concat(y);\n        if (updatedPositions.has(pos)) {\n            return; // Already updated in this frame\n        }\n        const element = grid[y][x];\n        // --- Out of Bounds Check ---\n        if (!areWallsOn) {\n            if (y <= 0 && (element === ELEMENT_TYPE.FIRE || element === ELEMENT_TYPE.SMOKE)) {\n                set(x, y, ELEMENT_TYPE.EMPTY);\n                return;\n            }\n            if (y >= height - 1 && DENSITIES[element] > DENSITIES[ELEMENT_TYPE.EMPTY]) {\n                set(x, y, ELEMENT_TYPE.EMPTY);\n                return;\n            }\n        }\n        // --- Movement Phase ---\n        // A particle will attempt to move, and if it does, its turn ends.\n        // Interactions only happen if a particle cannot move.\n        // Gas Movement (Up)\n        if (element === ELEMENT_TYPE.FIRE || element === ELEMENT_TYPE.SMOKE) {\n            // Gases are less likely to move, making them dissipate more naturally\n            if (Math.random() > 0.4) {\n                const dir = Math.random() < 0.5 ? -1 : 1;\n                // Up\n                if (isEmpty(x, y - 1)) {\n                    move(x, y, x, y - 1);\n                    updatedPositions.add(\"\".concat(x, \",\").concat(y - 1));\n                    return;\n                }\n                // Diagonal Up\n                if (isEmpty(x + dir, y - 1)) {\n                    move(x, y, x + dir, y - 1);\n                    updatedPositions.add(\"\".concat(x + dir, \",\").concat(y - 1));\n                    return;\n                }\n                // Sideways\n                if (isEmpty(x + dir, y)) {\n                    move(x, y, x + dir, y);\n                    updatedPositions.add(\"\".concat(x + dir, \",\").concat(y));\n                    return;\n                }\n            }\n        } else if (DENSITIES[element] > DENSITIES[ELEMENT_TYPE.EMPTY] && DENSITIES[element] < DENSITIES[ELEMENT_TYPE.WALL]) {\n            var _grid_, _grid_1, _grid_2;\n            const density = DENSITIES[element];\n            // Down\n            const below = (_grid_ = grid[y + 1]) === null || _grid_ === void 0 ? void 0 : _grid_[x];\n            if (below !== undefined && density > DENSITIES[below]) {\n                move(x, y, x, y + 1);\n                updatedPositions.add(\"\".concat(x, \",\").concat(y + 1));\n                return;\n            }\n            // Diagonal Down\n            const dir = Math.random() < 0.5 ? -1 : 1;\n            const diag1 = (_grid_1 = grid[y + 1]) === null || _grid_1 === void 0 ? void 0 : _grid_1[x + dir];\n            if (diag1 !== undefined && density > DENSITIES[diag1]) {\n                move(x, y, x + dir, y + 1);\n                updatedPositions.add(\"\".concat(x + dir, \",\").concat(y + 1));\n                return;\n            }\n            const diag2 = (_grid_2 = grid[y + 1]) === null || _grid_2 === void 0 ? void 0 : _grid_2[x - dir];\n            if (diag2 !== undefined && density > DENSITIES[diag2]) {\n                move(x, y, x - dir, y + 1);\n                updatedPositions.add(\"\".concat(x - dir, \",\").concat(y + 1));\n                return;\n            }\n            // Sideways (Liquids Only)\n            if (element === ELEMENT_TYPE.WATER || element === ELEMENT_TYPE.ACID || element === ELEMENT_TYPE.LAVA) {\n                const isSlow = element === ELEMENT_TYPE.LAVA && Math.random() < 0.5;\n                if (!isSlow) {\n                    if (isEmpty(x + dir, y)) {\n                        move(x, y, x + dir, y);\n                        updatedPositions.add(\"\".concat(x + dir, \",\").concat(y));\n                        return;\n                    }\n                    if (isEmpty(x - dir, y)) {\n                        move(x, y, x - dir, y);\n                        updatedPositions.add(\"\".concat(x - dir, \",\").concat(y));\n                        return;\n                    }\n                }\n            }\n        }\n        // --- Interaction Phase ---\n        // This code only runs if the particle did not move in the movement phase.\n        switch(element){\n            case ELEMENT_TYPE.LAVA:\n            case ELEMENT_TYPE.ACID:\n                for(let i = -1; i <= 1; i++){\n                    for(let j = -1; j <= 1; j++){\n                        var _grid_3;\n                        if (i === 0 && j === 0) continue;\n                        const neighbor = (_grid_3 = grid[y + j]) === null || _grid_3 === void 0 ? void 0 : _grid_3[x + i];\n                        if (neighbor === undefined || neighbor === ELEMENT_TYPE.WALL || neighbor === element) continue;\n                        if (is(x + i, y + j, ELEMENT_TYPE.LAVA) && element === ELEMENT_TYPE.ACID) {\n                            set(x + i, y + j, ELEMENT_TYPE.SMOKE);\n                            set(x, y, ELEMENT_TYPE.SMOKE);\n                        } else if (neighbor !== ELEMENT_TYPE.EMPTY) {\n                            set(x + i, y + j, ELEMENT_TYPE.FIRE);\n                            if (element === ELEMENT_TYPE.ACID && Math.random() < 0.2) {\n                                set(x, y, ELEMENT_TYPE.EMPTY);\n                            }\n                        }\n                    }\n                }\n                break;\n            case ELEMENT_TYPE.FIRE:\n                if (Math.random() < 0.05) {\n                    set(x, y, ELEMENT_TYPE.HOT_ASH);\n                }\n                break;\n            case ELEMENT_TYPE.HOT_ASH:\n                if (Math.random() < 0.05) {\n                    set(x, y, ELEMENT_TYPE.ASH);\n                    break;\n                }\n                for(let i = -1; i <= 1; i++){\n                    for(let j = -1; j <= 1; j++){\n                        var _grid_4;\n                        if (i === 0 && j === 0) continue;\n                        const neighbor = (_grid_4 = grid[y + j]) === null || _grid_4 === void 0 ? void 0 : _grid_4[x + i];\n                        if (neighbor === undefined) continue;\n                        if (neighbor === ELEMENT_TYPE.WATER) {\n                            set(x, y, ELEMENT_TYPE.ASH);\n                            set(x + i, y + j, ELEMENT_TYPE.SMOKE);\n                        } else if (neighbor !== ELEMENT_TYPE.ASH && neighbor !== ELEMENT_TYPE.HOT_ASH && DENSITIES[neighbor] > 0 && DENSITIES[neighbor] < DENSITIES[ELEMENT_TYPE.LAVA]) {\n                            if (Math.random() < 0.05) {\n                                set(x + i, y + j, ELEMENT_TYPE.FIRE);\n                                set(x, y, ELEMENT_TYPE.ASH);\n                            }\n                        } else if (neighbor === ELEMENT_TYPE.ASH || neighbor === ELEMENT_TYPE.HOT_ASH) {\n                            if (Math.random() < 0.001) {\n                                set(x + i, y + j, ELEMENT_TYPE.FIRE);\n                                set(x, y, ELEMENT_TYPE.ASH);\n                            }\n                        }\n                    }\n                }\n                break;\n            case ELEMENT_TYPE.STONE_ASH:\n                var _grid_5;\n                const isStable = DENSITIES[(_grid_5 = grid[y + 1]) === null || _grid_5 === void 0 ? void 0 : _grid_5[x]] >= DENSITIES[ELEMENT_TYPE.STONE_ASH];\n                if (isStable && Math.random() < 0.01) {\n                    set(x, y, ELEMENT_TYPE.STONE);\n                }\n                break;\n            case ELEMENT_TYPE.PLANT:\n                if (Math.random() < 0.05) {\n                    for(let i = -1; i <= 1; i++){\n                        for(let j = -1; j <= 1; j++){\n                            if (is(x + i, y + j, ELEMENT_TYPE.WATER)) {\n                                // Try to grow into an empty space nearby\n                                const growX = x - i;\n                                const growY = y - j;\n                                if (isEmpty(growX, growY)) {\n                                    set(growX, growY, ELEMENT_TYPE.PLANT);\n                                }\n                            }\n                        }\n                    }\n                }\n                break;\n            case ELEMENT_TYPE.SMOKE:\n                // If smoke is stuck, it has a chance to disappear.\n                if (Math.random() < 0.01) {\n                    set(x, y, ELEMENT_TYPE.EMPTY);\n                }\n                break;\n        }\n        updatedPositions.add(pos);\n    };\n    // Iterate through the grid and update elements\n    for(let y = height - 2; y > 0; y--){\n        const scanDirection = Math.random() < 0.5 ? 1 : -1;\n        if (scanDirection === 1) {\n            for(let x = 1; x < width - 1; x++){\n                updateElement(x, y);\n            }\n        } else {\n            for(let x = width - 2; x > 0; x--){\n                updateElement(x, y);\n            }\n        }\n    }\n    // Process solids (non-moving but interactive elements)\n    for(let y = 0; y < height; y++){\n        for(let x = 0; x < width; x++){\n            if (grid[y][x] === ELEMENT_TYPE.PLANT) {\n                updateElement(x, y);\n            }\n        }\n    }\n    // Iterate top-to-bottom for rising particles\n    for(let y = 0; y < height; y++){\n        for(let x = 0; x < width; x++){\n            if (grid[y][x] === ELEMENT_TYPE.SMOKE || grid[y][x] === ELEMENT_TYPE.FIRE) {\n                updateElement(x, y);\n            }\n        }\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvc2ltdWxhdGlvbi93b3JsZC50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFPLE1BQU1BLGVBQWU7SUFDMUJDLE9BQU87SUFDUEMsTUFBTTtJQUNOQyxNQUFNO0lBQ05DLE9BQU87SUFDUEMsT0FBTztJQUNQQyxNQUFNO0lBQ05DLE1BQU07SUFDTkMsTUFBTTtJQUNOQyxPQUFPO0lBQ1BDLE9BQU87SUFDUEMsV0FBVztJQUNYQyxLQUFLO0lBQ0xDLFNBQVM7QUFDWCxFQUFXO0FBSUosTUFBTUMsaUJBQThDO0lBQ3ZELENBQUNkLGFBQWFDLEtBQUssQ0FBQyxFQUFFO0lBQ3RCLENBQUNELGFBQWFFLElBQUksQ0FBQyxFQUFFO0lBQ3JCLENBQUNGLGFBQWFHLElBQUksQ0FBQyxFQUFFO0lBQ3JCLENBQUNILGFBQWFJLEtBQUssQ0FBQyxFQUFFO0lBQ3RCLENBQUNKLGFBQWFLLEtBQUssQ0FBQyxFQUFFO0lBQ3RCLENBQUNMLGFBQWFNLElBQUksQ0FBQyxFQUFFO0lBQ3JCLENBQUNOLGFBQWFPLElBQUksQ0FBQyxFQUFFO0lBQ3JCLENBQUNQLGFBQWFRLElBQUksQ0FBQyxFQUFFO0lBQ3JCLENBQUNSLGFBQWFTLEtBQUssQ0FBQyxFQUFFO0lBQ3RCLENBQUNULGFBQWFVLEtBQUssQ0FBQyxFQUFFO0lBQ3RCLENBQUNWLGFBQWFXLFNBQVMsQ0FBQyxFQUFFO0lBQzFCLENBQUNYLGFBQWFZLEdBQUcsQ0FBQyxFQUFFO0lBQ3BCLENBQUNaLGFBQWFhLE9BQU8sQ0FBQyxFQUFFO0FBQzVCLEVBQUU7QUFFSyxNQUFNRSxZQUF5QztJQUNsRCxDQUFDZixhQUFhQyxLQUFLLENBQUMsRUFBRTtJQUN0QixDQUFDRCxhQUFhUyxLQUFLLENBQUMsRUFBRTtJQUN0QixDQUFDVCxhQUFhTSxJQUFJLENBQUMsRUFBRTtJQUNyQixDQUFDTixhQUFhSSxLQUFLLENBQUMsRUFBRTtJQUN0QixDQUFDSixhQUFhUSxJQUFJLENB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SUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlSLE9BQU9RLElBQUs7WUFDM0IsSUFBSU4sSUFBSSxDQUFDSyxFQUFFLENBQUNDLEVBQUUsS0FBSzNCLGFBQWFTLEtBQUssSUFBSVksSUFBSSxDQUFDSyxFQUFFLENBQUNDLEVBQUUsS0FBSzNCLGFBQWFNLElBQUksRUFBRTtnQkFDdkVvRSxjQUFjL0MsR0FBR0Q7WUFDdEI7UUFDSjtJQUNKO0FBQ0osRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvYXBwL3NpbXVsYXRpb24vd29ybGQudHM/NjU1NiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgRUxFTUVOVF9UWVBFID0ge1xyXG4gIEVNUFRZOiAwLFxyXG4gIFdBTEw6IDEsXHJcbiAgU0FORDogMixcclxuICBXQVRFUjogMyxcclxuICBQTEFOVDogNCxcclxuICBGSVJFOiA1LFxyXG4gIExBVkE6IDYsXHJcbiAgQUNJRDogNyxcclxuICBTTU9LRTogOCxcclxuICBTVE9ORTogOSxcclxuICBTVE9ORV9BU0g6IDEwLFxyXG4gIEFTSDogMTEsXHJcbiAgSE9UX0FTSDogMTIsXHJcbn0gYXMgY29uc3Q7XHJcblxyXG5leHBvcnQgdHlwZSBFbGVtZW50VHlwZSA9IHR5cGVvZiBFTEVNRU5UX1RZUEVba2V5b2YgdHlwZW9mIEVMRU1FTlRfVFlQRV07XHJcblxyXG5leHBvcnQgY29uc3QgRUxFTUVOVF9DT0xPUlM6IFJlY29yZDxFbGVtZW50VHlwZSwgc3RyaW5nPiA9IHtcclxuICAgIFtFTEVNRU5UX1RZUEUuRU1QVFldOiAnIzAwMDAwMCcsXHJcbiAgICBbRUxFTUVOVF9UWVBFLldBTExdOiAnIzUwNTA1MCcsXHJcbiAgICBbRUxFTUVOVF9UWVBFLlNBTkRdOiAnI2YwZDlhNScsXHJcbiAgICBbRUxFTUVOVF9UWVBFLldBVEVSXTogJyMzNDk4ZGInLFxyXG4gICAgW0VMRU1FTlRfVFlQRS5QTEFOVF06ICcjMmVjYzcxJyxcclxuICAgIFtFTEVNRU5UX1RZUEUuRklSRV06ICcjZTc0YzNjJyxcclxuICAgIFtFTEVNRU5UX1RZUEUuTEFWQV06ICcjZDM1NDAwJyxcclxuICAgIFtFTEVNRU5UX1RZUEUuQUNJRF06ICcjOWI1OWI2JyxcclxuICAgIFtFTEVNRU5UX1RZUEUuU01PS0VdOiAnIzg4ODg4OCcsXHJcbiAgICBbRUxFTUVOVF9UWVBFLlNUT05FXTogJyM4MDgwODAnLFxyXG4gICAgW0VMRU1FTlRfVFlQRS5TVE9ORV9BU0hdOiAnIzZiNmI2YicsXHJcbiAgICBbRUxFTUVOVF9UWVBFLkFTSF06ICcjMmIyYjJiJyxcclxuICAgIFtFTEVNRU5UX1RZUEUuSE9UX0FTSF06ICcjZGI0ZjI3JyxcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBERU5TSVRJRVM6IFJlY29yZDxFbGVtZW50VHlwZSwgbnVtYmVyPiA9IHtcclxuICAgIFtFTEVNRU5UX1RZUEUuRU1QVFldOiAwLFxyXG4gICAgW0VMRU1FTlRfVFlQRS5TTU9LRV06IDEsXHJcbiAgICBbRUxFTUVOVF9UWVBFLkZJUkVdOiAxLFxyXG4gICAgW0VMRU1FTlRfVFlQRS5XQVRFUl06IDEwLFxyXG4gICAgW0VMRU1FTlRfVFlQRS5BQ0lEXTogMTEsXHJcbiAgICBbRUxFTUVOVF9UWVBFLkFTSF06IDEyLFxyXG4gICAgW0VMRU1FTlRfVFlQRS5IT1RfQVNIXTogMTIsXHJcbiAgICBbRUxFTUVOVF9UWVBFLlNBTkRdOiAxNSxcclxuICAgIFtFTEVNRU5UX1RZUEUuUExBTlRdOiAyMCxcclxuICAgIFtFTEVNRU5UX1RZUEUuU1RPTkVfQVNIXTogMjIsXHJcbiAgICBbRUxFTUVOVF9UWVBFLkxBVkFdOiAyNSxcclxuICAgIFtFTEVNRU5UX1RZUEUuU1RPTkVdOiAzMCxcclxuICAgIFtFTEVNRU5UX1RZUEUuV0FMTF06IEluZmluaXR5LFxyXG59O1xyXG5cclxuY29uc3QgTE9DQUxfU1RPUkFHRV9LRVkgPSAnc2FuZFNpbXVsYXRpb25HcmlkJztcclxuY29uc3QgQ0VMTF9TSVpFID0gNTtcclxubGV0IHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyO1xyXG5sZXQgZ3JpZDogRWxlbWVudFR5cGVbXVtdO1xyXG5sZXQgYXJlV2FsbHNPbiA9IHRydWU7XHJcblxyXG5leHBvcnQgY29uc3Qgc2V0V2FsbHMgPSAoZW5hYmxlZDogYm9vbGVhbikgPT4ge1xyXG4gICAgYXJlV2FsbHNPbiA9IGVuYWJsZWQ7XHJcbiAgICBjb25zdCB3YWxsVHlwZSA9IGVuYWJsZWQgPyBFTEVNRU5UX1RZUEUuV0FMTCA6IEVMRU1FTlRfVFlQRS5FTVBUWTtcclxuXHJcbiAgICBpZiAoIWdyaWQpIHJldHVybjtcclxuXHJcbiAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGhlaWdodDsgeSsrKSB7XHJcbiAgICAgICAgaWYgKGdyaWRbeV0pIHtcclxuICAgICAgICAgICAgZ3JpZFt5XVswXSA9IHdhbGxUeXBlO1xyXG4gICAgICAgICAgICBncmlkW3ldW3dpZHRoIC0gMV0gPSB3YWxsVHlwZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHdpZHRoOyB4KyspIHtcclxuICAgICAgICBpZiAoZ3JpZFswXSkgZ3JpZFswXVt4XSA9IHdhbGxUeXBlO1xyXG4gICAgICAgIGlmIChncmlkW2hlaWdodCAtIDFdKSBncmlkW2hlaWdodCAtIDFdW3hdID0gd2FsbFR5cGU7XHJcbiAgICB9XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3Qgc2F2ZVdvcmxkID0gKCkgPT4ge1xyXG4gICAgaWYgKGdyaWQpIHtcclxuICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShMT0NBTF9TVE9SQUdFX0tFWSwgSlNPTi5zdHJpbmdpZnkoZ3JpZCkpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGNsZWFyID0gKCkgPT4ge1xyXG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKykge1xyXG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgd2lkdGg7IHgrKykge1xyXG4gICAgICAgICAgICBncmlkW3ldW3hdID0gRUxFTUVOVF9UWVBFLkVNUFRZO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChhcmVXYWxsc09uKSB7XHJcbiAgICAgICAgc2V0V2FsbHModHJ1ZSk7XHJcbiAgICB9XHJcbiAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShMT0NBTF9TVE9SQUdFX0tFWSk7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgaW5pdCA9IChjYW52YXNXaWR0aDogbnVtYmVyLCBjYW52YXNIZWlnaHQ6IG51bWJlcikgPT4ge1xyXG4gICAgd2lkdGggPSBNYXRoLmZsb29yKGNhbnZhc1dpZHRoIC8gQ0VMTF9TSVpFKTtcclxuICAgIGhlaWdodCA9IE1hdGguZmxvb3IoY2FudmFzSGVpZ2h0IC8gQ0VMTF9TSVpFKTtcclxuXHJcbiAgICBjb25zdCBzYXZlZEdyaWQgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShMT0NBTF9TVE9SQUdFX0tFWSk7XHJcbiAgICBcclxuICAgIGlmIChzYXZlZEdyaWQpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjb25zdCBwYXJzZWRHcmlkID0gSlNPTi5wYXJzZShzYXZlZEdyaWQpO1xyXG4gICAgICAgICAgICBpZiAocGFyc2VkR3JpZCAmJiBwYXJzZWRHcmlkLmxlbmd0aCA9PT0gaGVpZ2h0ICYmIHBhcnNlZEdyaWRbMF0ubGVuZ3RoID09PSB3aWR0aCkge1xyXG4gICAgICAgICAgICAgICAgZ3JpZCA9IHBhcnNlZEdyaWQ7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gcGFyc2Ugc2F2ZWQgZ3JpZDpcIiwgZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGdyaWQgPSBBcnJheShoZWlnaHQpLmZpbGwoMCkubWFwKCgpID0+IEFycmF5KHdpZHRoKS5maWxsKEVMRU1FTlRfVFlQRS5FTVBUWSkpO1xyXG4gICAgc2V0V2FsbHMoYXJlV2FsbHNPbik7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgZ2V0R3JpZCA9ICgpID0+IGdyaWQ7XHJcbmV4cG9ydCBjb25zdCBnZXRDZWxsU2l6ZSA9ICgpID0+IENFTExfU0laRTtcclxuXHJcbmV4cG9ydCBjb25zdCBzZXRFbGVtZW50ID0gKHg6IG51bWJlciwgeTogbnVtYmVyLCBlbGVtZW50VHlwZTogRWxlbWVudFR5cGUsIGJydXNoU2l6ZTogbnVtYmVyKSA9PiB7XHJcbiAgICBjb25zdCByYWRpdXMgPSBNYXRoLmZsb29yKGJydXNoU2l6ZSAvIENFTExfU0laRSAvIDIpO1xyXG4gICAgZm9yIChsZXQgaSA9IC1yYWRpdXM7IGkgPD0gcmFkaXVzOyBpKyspIHtcclxuICAgICAgICBmb3IgKGxldCBqID0gLXJhZGl1czsgaiA8PSByYWRpdXM7IGorKykge1xyXG4gICAgICAgICAgICBpZiAoaSppICsgaipqIDw9IHJhZGl1cypyYWRpdXMpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1ggPSB4ICsgaTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1kgPSB5ICsgajtcclxuICAgICAgICAgICAgICAgIGlmIChuZXdYID49IDAgJiYgbmV3WCA8IHdpZHRoICYmIG5ld1kgPj0gMCAmJiBuZXdZIDwgaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGdyaWRbbmV3WV1bbmV3WF0gPT09IEVMRU1FTlRfVFlQRS5FTVBUWSB8fCBlbGVtZW50VHlwZSA9PT0gRUxFTUVOVF9UWVBFLkVNUFRZKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyaWRbbmV3WV1bbmV3WF0gPSBlbGVtZW50VHlwZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG5jb25zdCBtb3ZlID0gKHgxOiBudW1iZXIsIHkxOiBudW1iZXIsIHgyOiBudW1iZXIsIHkyOiBudW1iZXIpID0+IHtcclxuICAgIGNvbnN0IHRlbXAgPSBncmlkW3kxXVt4MV07XHJcbiAgICBncmlkW3kxXVt4MV0gPSBncmlkW3kyXVt4Ml07XHJcbiAgICBncmlkW3kyXVt4Ml0gPSB0ZW1wO1xyXG59XHJcblxyXG5jb25zdCBpc1dpdGhpbkJvdW5kcyA9ICh4OiBudW1iZXIsIHk6IG51bWJlcikgPT4ge1xyXG4gICAgcmV0dXJuIHkgPj0gMCAmJiB5IDwgaGVpZ2h0ICYmIHggPj0gMCAmJiB4IDwgd2lkdGg7XHJcbn1cclxuXHJcbmNvbnN0IGlzRW1wdHkgPSAoeDogbnVtYmVyLCB5OiBudW1iZXIpID0+IHtcclxuICAgIHJldHVybiBpc1dpdGhpbkJvdW5kcyh4LCB5KSAmJiBncmlkW3ldW3hdID09PSBFTEVNRU5UX1RZUEUuRU1QVFk7XHJcbn1cclxuXHJcbmNvbnN0IGlzID0gKHg6IG51bWJlciwgeTogbnVtYmVyLCBlbGVtZW50VHlwZTogRWxlbWVudFR5cGUpID0+IHtcclxuICAgIHJldHVybiBpc1dpdGhpbkJvdW5kcyh4LCB5KSAmJiBncmlkW3ldW3hdID09PSBlbGVtZW50VHlwZTtcclxufVxyXG5cclxuY29uc3Qgc2V0ID0gKHg6IG51bWJlciwgeTogbnVtYmVyLCBlbGVtZW50VHlwZTogRWxlbWVudFR5cGUpID0+IHtcclxuICAgIGlmIChpc1dpdGhpbkJvdW5kcyh4LCB5KSkge1xyXG4gICAgICAgIGdyaWRbeV1beF0gPSBlbGVtZW50VHlwZTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IHVwZGF0ZSA9ICgpID0+IHtcclxuICAgIGNvbnN0IHVwZGF0ZWRQb3NpdGlvbnMgPSBuZXcgU2V0PHN0cmluZz4oKTtcclxuXHJcbiAgICBjb25zdCB1cGRhdGVFbGVtZW50ID0gKHg6IG51bWJlciwgeTogbnVtYmVyKSA9PiB7XHJcbiAgICAgICAgY29uc3QgcG9zID0gYCR7eH0sJHt5fWA7XHJcbiAgICAgICAgaWYgKHVwZGF0ZWRQb3NpdGlvbnMuaGFzKHBvcykpIHtcclxuICAgICAgICAgICAgcmV0dXJuOyAvLyBBbHJlYWR5IHVwZGF0ZWQgaW4gdGhpcyBmcmFtZVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IGdyaWRbeV1beF07XHJcblxyXG4gICAgICAgIC8vIC0tLSBPdXQgb2YgQm91bmRzIENoZWNrIC0tLVxyXG4gICAgICAgIGlmICghYXJlV2FsbHNPbikge1xyXG4gICAgICAgICAgICBpZiAoeSA8PSAwICYmIChlbGVtZW50ID09PSBFTEVNRU5UX1RZUEUuRklSRSB8fCBlbGVtZW50ID09PSBFTEVNRU5UX1RZUEUuU01PS0UpKSB7XHJcbiAgICAgICAgICAgICAgICBzZXQoeCwgeSwgRUxFTUVOVF9UWVBFLkVNUFRZKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoeSA+PSBoZWlnaHQgLSAxICYmIERFTlNJVElFU1tlbGVtZW50XSA+IERFTlNJVElFU1tFTEVNRU5UX1RZUEUuRU1QVFldKSB7XHJcbiAgICAgICAgICAgICAgICAgc2V0KHgsIHksIEVMRU1FTlRfVFlQRS5FTVBUWSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIC0tLSBNb3ZlbWVudCBQaGFzZSAtLS1cclxuICAgICAgICAvLyBBIHBhcnRpY2xlIHdpbGwgYXR0ZW1wdCB0byBtb3ZlLCBhbmQgaWYgaXQgZG9lcywgaXRzIHR1cm4gZW5kcy5cclxuICAgICAgICAvLyBJbnRlcmFjdGlvbnMgb25seSBoYXBwZW4gaWYgYSBwYXJ0aWNsZSBjYW5ub3QgbW92ZS5cclxuXHJcbiAgICAgICAgLy8gR2FzIE1vdmVtZW50IChVcClcclxuICAgICAgICBpZiAoZWxlbWVudCA9PT0gRUxFTUVOVF9UWVBFLkZJUkUgfHwgZWxlbWVudCA9PT0gRUxFTUVOVF9UWVBFLlNNT0tFKSB7XHJcbiAgICAgICAgICAgIC8vIEdhc2VzIGFyZSBsZXNzIGxpa2VseSB0byBtb3ZlLCBtYWtpbmcgdGhlbSBkaXNzaXBhdGUgbW9yZSBuYXR1cmFsbHlcclxuICAgICAgICAgICAgaWYgKE1hdGgucmFuZG9tKCkgPiAwLjQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRpciA9IE1hdGgucmFuZG9tKCkgPCAwLjUgPyAtMSA6IDE7XHJcbiAgICAgICAgICAgICAgICAvLyBVcFxyXG4gICAgICAgICAgICAgICAgaWYgKGlzRW1wdHkoeCwgeSAtIDEpKSB7IG1vdmUoeCwgeSwgeCwgeSAtIDEpOyB1cGRhdGVkUG9zaXRpb25zLmFkZChgJHt4fSwke3ktMX1gKTsgcmV0dXJuOyB9XHJcbiAgICAgICAgICAgICAgICAvLyBEaWFnb25hbCBVcFxyXG4gICAgICAgICAgICAgICAgaWYgKGlzRW1wdHkoeCArIGRpciwgeSAtIDEpKSB7IG1vdmUoeCwgeSwgeCArIGRpciwgeSAtIDEpOyB1cGRhdGVkUG9zaXRpb25zLmFkZChgJHt4K2Rpcn0sJHt5LTF9YCk7IHJldHVybjsgfVxyXG4gICAgICAgICAgICAgICAgLy8gU2lkZXdheXNcclxuICAgICAgICAgICAgICAgIGlmIChpc0VtcHR5KHggKyBkaXIsIHkpKSB7IG1vdmUoeCwgeSwgeCArIGRpciwgeSk7IHVwZGF0ZWRQb3NpdGlvbnMuYWRkKGAke3grZGlyfSwke3l9YCk7IHJldHVybjsgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEZhbGxpbmcgUGFydGljbGUgTW92ZW1lbnQgKFBvd2RlcnMgJiBMaXF1aWRzKVxyXG4gICAgICAgIGVsc2UgaWYgKERFTlNJVElFU1tlbGVtZW50XSA+IERFTlNJVElFU1tFTEVNRU5UX1RZUEUuRU1QVFldICYmIERFTlNJVElFU1tlbGVtZW50XSA8IERFTlNJVElFU1tFTEVNRU5UX1RZUEUuV0FMTF0pIHtcclxuICAgICAgICAgICAgY29uc3QgZGVuc2l0eSA9IERFTlNJVElFU1tlbGVtZW50XTtcclxuXHJcbiAgICAgICAgICAgIC8vIERvd25cclxuICAgICAgICAgICAgY29uc3QgYmVsb3cgPSBncmlkW3kgKyAxXT8uW3hdO1xyXG4gICAgICAgICAgICBpZiAoYmVsb3cgIT09IHVuZGVmaW5lZCAmJiBkZW5zaXR5ID4gREVOU0lUSUVTW2JlbG93XSkge1xyXG4gICAgICAgICAgICAgICAgbW92ZSh4LCB5LCB4LCB5ICsgMSk7IHVwZGF0ZWRQb3NpdGlvbnMuYWRkKGAke3h9LCR7eSsxfWApOyByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIERpYWdvbmFsIERvd25cclxuICAgICAgICAgICAgY29uc3QgZGlyID0gTWF0aC5yYW5kb20oKSA8IDAuNSA/IC0xIDogMTtcclxuICAgICAgICAgICAgY29uc3QgZGlhZzEgPSBncmlkW3kgKyAxXT8uW3ggKyBkaXJdO1xyXG4gICAgICAgICAgICBpZiAoZGlhZzEgIT09IHVuZGVmaW5lZCAmJiBkZW5zaXR5ID4gREVOU0lUSUVTW2RpYWcxXSkge1xyXG4gICAgICAgICAgICAgICAgbW92ZSh4LCB5LCB4ICsgZGlyLCB5ICsgMSk7IHVwZGF0ZWRQb3NpdGlvbnMuYWRkKGAke3grZGlyfSwke3krMX1gKTsgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGRpYWcyID0gZ3JpZFt5ICsgMV0/Llt4IC0gZGlyXTtcclxuICAgICAgICAgICAgaWYgKGRpYWcyICE9PSB1bmRlZmluZWQgJiYgZGVuc2l0eSA+IERFTlNJVElFU1tkaWFnMl0pIHtcclxuICAgICAgICAgICAgICAgIG1vdmUoeCwgeSwgeCAtIGRpciwgeSArIDEpOyB1cGRhdGVkUG9zaXRpb25zLmFkZChgJHt4LWRpcn0sJHt5KzF9YCk7IHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gU2lkZXdheXMgKExpcXVpZHMgT25seSlcclxuICAgICAgICAgICAgaWYgKGVsZW1lbnQgPT09IEVMRU1FTlRfVFlQRS5XQVRFUiB8fCBlbGVtZW50ID09PSBFTEVNRU5UX1RZUEUuQUNJRCB8fCBlbGVtZW50ID09PSBFTEVNRU5UX1RZUEUuTEFWQSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaXNTbG93ID0gKGVsZW1lbnQgPT09IEVMRU1FTlRfVFlQRS5MQVZBICYmIE1hdGgucmFuZG9tKCkgPCAwLjUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc1Nsb3cpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNFbXB0eSh4ICsgZGlyLCB5KSkgeyBtb3ZlKHgsIHksIHggKyBkaXIsIHkpOyB1cGRhdGVkUG9zaXRpb25zLmFkZChgJHt4K2Rpcn0sJHt5fWApOyByZXR1cm47IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNFbXB0eSh4IC0gZGlyLCB5KSkgeyBtb3ZlKHgsIHksIHggLSBkaXIsIHkpOyB1cGRhdGVkUG9zaXRpb25zLmFkZChgJHt4LWRpcn0sJHt5fWApOyByZXR1cm47IH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gLS0tIEludGVyYWN0aW9uIFBoYXNlIC0tLVxyXG4gICAgICAgIC8vIFRoaXMgY29kZSBvbmx5IHJ1bnMgaWYgdGhlIHBhcnRpY2xlIGRpZCBub3QgbW92ZSBpbiB0aGUgbW92ZW1lbnQgcGhhc2UuXHJcbiAgICAgICAgc3dpdGNoKGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgY2FzZSBFTEVNRU5UX1RZUEUuTEFWQTpcclxuICAgICAgICAgICAgY2FzZSBFTEVNRU5UX1RZUEUuQUNJRDpcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAtMTsgaSA8PSAxOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gLTE7IGogPD0gMTsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpID09PSAwICYmIGogPT09IDApIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZWlnaGJvciA9IGdyaWRbeSArIGpdPy5beCArIGldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmVpZ2hib3IgPT09IHVuZGVmaW5lZCB8fCBuZWlnaGJvciA9PT0gRUxFTUVOVF9UWVBFLldBTEwgfHwgbmVpZ2hib3IgPT09IGVsZW1lbnQpIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzKHggKyBpLCB5ICsgaiwgRUxFTUVOVF9UWVBFLkxBVkEpICYmIGVsZW1lbnQgPT09IEVMRU1FTlRfVFlQRS5BQ0lEKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXQoeCArIGksIHkgKyBqLCBFTEVNRU5UX1RZUEUuU01PS0UpOyBzZXQoeCwgeSwgRUxFTUVOVF9UWVBFLlNNT0tFKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChuZWlnaGJvciAhPT0gRUxFTUVOVF9UWVBFLkVNUFRZKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXQoeCArIGksIHkgKyBqLCBFTEVNRU5UX1RZUEUuRklSRSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudCA9PT0gRUxFTUVOVF9UWVBFLkFDSUQgJiYgTWF0aC5yYW5kb20oKSA8IDAuMikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldCh4LCB5LCBFTEVNRU5UX1RZUEUuRU1QVFkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgRUxFTUVOVF9UWVBFLkZJUkU6XHJcbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5yYW5kb20oKSA8IDAuMDUpIHsgc2V0KHgsIHksIEVMRU1FTlRfVFlQRS5IT1RfQVNIKTsgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgRUxFTUVOVF9UWVBFLkhPVF9BU0g6XHJcbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5yYW5kb20oKSA8IDAuMDUpIHsgc2V0KHgsIHksIEVMRU1FTlRfVFlQRS5BU0gpOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAtMTsgaSA8PSAxOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gLTE7IGogPD0gMTsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpID09PSAwICYmIGogPT09IDApIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZWlnaGJvciA9IGdyaWRbeSArIGpdPy5beCArIGldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmVpZ2hib3IgPT09IHVuZGVmaW5lZCkgY29udGludWU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmVpZ2hib3IgPT09IEVMRU1FTlRfVFlQRS5XQVRFUikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0KHgsIHksIEVMRU1FTlRfVFlQRS5BU0gpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0KHggKyBpLCB5ICsgaiwgRUxFTUVOVF9UWVBFLlNNT0tFKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWduaXRlIG90aGVyIGZsYW1tYWJsZSB0aGluZ3MgKGJ1dCBub3QgYXNoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5laWdoYm9yICE9PSBFTEVNRU5UX1RZUEUuQVNIICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZWlnaGJvciAhPT0gRUxFTUVOVF9UWVBFLkhPVF9BU0ggJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIERFTlNJVElFU1tuZWlnaGJvcl0gPiAwICYmIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgREVOU0lUSUVTW25laWdoYm9yXSA8IERFTlNJVElFU1tFTEVNRU5UX1RZUEUuTEFWQV1cclxuICAgICAgICAgICAgICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoTWF0aC5yYW5kb20oKSA8IDAuMDUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXQoeCArIGksIHkgKyBqLCBFTEVNRU5UX1RZUEUuRklSRSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0KHgsIHksIEVMRU1FTlRfVFlQRS5BU0gpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZ25pdGUgb3RoZXIgYXNoICh2ZXJ5IGxvdyBjaGFuY2UpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5laWdoYm9yID09PSBFTEVNRU5UX1RZUEUuQVNIIHx8IG5laWdoYm9yID09PSBFTEVNRU5UX1RZUEUuSE9UX0FTSCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE1hdGgucmFuZG9tKCkgPCAwLjAwMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldCh4ICsgaSwgeSArIGosIEVMRU1FTlRfVFlQRS5GSVJFKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXQoeCwgeSwgRUxFTUVOVF9UWVBFLkFTSCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBFTEVNRU5UX1RZUEUuU1RPTkVfQVNIOlxyXG4gICAgICAgICAgICAgICAgY29uc3QgaXNTdGFibGUgPSAoREVOU0lUSUVTW2dyaWRbeSsxXT8uW3hdXSA+PSBERU5TSVRJRVNbRUxFTUVOVF9UWVBFLlNUT05FX0FTSF0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzU3RhYmxlICYmIE1hdGgucmFuZG9tKCkgPCAwLjAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0KHgsIHksIEVMRU1FTlRfVFlQRS5TVE9ORSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBFTEVNRU5UX1RZUEUuUExBTlQ6XHJcbiAgICAgICAgICAgICAgICAgaWYgKE1hdGgucmFuZG9tKCkgPCAwLjA1KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IC0xOyBpIDw9IDE7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gLTE7IGogPD0gMTsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXMoeCArIGksIHkgKyBqLCBFTEVNRU5UX1RZUEUuV0FURVIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUcnkgdG8gZ3JvdyBpbnRvIGFuIGVtcHR5IHNwYWNlIG5lYXJieVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZ3Jvd1ggPSB4IC0gaTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGdyb3dZID0geSAtIGo7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNFbXB0eShncm93WCwgZ3Jvd1kpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0KGdyb3dYLCBncm93WSwgRUxFTUVOVF9UWVBFLlBMQU5UKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIEVMRU1FTlRfVFlQRS5TTU9LRTpcclxuICAgICAgICAgICAgICAgIC8vIElmIHNtb2tlIGlzIHN0dWNrLCBpdCBoYXMgYSBjaGFuY2UgdG8gZGlzYXBwZWFyLlxyXG4gICAgICAgICAgICAgICAgaWYgKE1hdGgucmFuZG9tKCkgPCAwLjAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0KHgsIHksIEVMRU1FTlRfVFlQRS5FTVBUWSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHVwZGF0ZWRQb3NpdGlvbnMuYWRkKHBvcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSXRlcmF0ZSB0aHJvdWdoIHRoZSBncmlkIGFuZCB1cGRhdGUgZWxlbWVudHNcclxuICAgIGZvciAobGV0IHkgPSBoZWlnaHQgLSAyOyB5ID4gMDsgeS0tKSB7XHJcbiAgICAgICAgY29uc3Qgc2NhbkRpcmVjdGlvbiA9IE1hdGgucmFuZG9tKCkgPCAwLjUgPyAxIDogLTE7XHJcbiAgICAgICAgaWYgKHNjYW5EaXJlY3Rpb24gPT09IDEpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgeCA9IDE7IHggPCB3aWR0aCAtIDE7IHgrKykge1xyXG4gICAgICAgICAgICAgICAgdXBkYXRlRWxlbWVudCh4LCB5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IHggPSB3aWR0aCAtIDI7IHggPiAwOyB4LS0pIHtcclxuICAgICAgICAgICAgICAgIHVwZGF0ZUVsZW1lbnQoeCwgeSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUHJvY2VzcyBzb2xpZHMgKG5vbi1tb3ZpbmcgYnV0IGludGVyYWN0aXZlIGVsZW1lbnRzKVxyXG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKykge1xyXG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgd2lkdGg7IHgrKykge1xyXG4gICAgICAgICAgICAgaWYgKGdyaWRbeV1beF0gPT09IEVMRU1FTlRfVFlQRS5QTEFOVCkge1xyXG4gICAgICAgICAgICAgICAgIHVwZGF0ZUVsZW1lbnQoeCwgeSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSXRlcmF0ZSB0b3AtdG8tYm90dG9tIGZvciByaXNpbmcgcGFydGljbGVzXHJcbiAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGhlaWdodDsgeSsrKSB7XHJcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB3aWR0aDsgeCsrKSB7XHJcbiAgICAgICAgICAgICBpZiAoZ3JpZFt5XVt4XSA9PT0gRUxFTUVOVF9UWVBFLlNNT0tFIHx8IGdyaWRbeV1beF0gPT09IEVMRU1FTlRfVFlQRS5GSVJFKSB7XHJcbiAgICAgICAgICAgICAgICAgdXBkYXRlRWxlbWVudCh4LCB5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufTsgIl0sIm5hbWVzIjpbIkVMRU1FTlRfVFlQRSIsIkVNUFRZIiwiV0FMTCIsIlNBTkQiLCJXQVRFUiIsIlBMQU5UIiwiRklSRSIsIkxBVkEiLCJBQ0lEIiwiU01PS0UiLCJTVE9ORSIsIlNUT05FX0FTSCIsIkFTSCIsIkhPVF9BU0giLCJFTEVNRU5UX0NPTE9SUyIsIkRFTlNJVElFUyIsIkluZmluaXR5IiwiTE9DQUxfU1RPUkFHRV9LRVkiLCJDRUxMX1NJWkUiLCJ3aWR0aCIsImhlaWdodCIsImdyaWQiLCJhcmVXYWxsc09uIiwic2V0V2FsbHMiLCJlbmFibGVkIiwid2FsbFR5cGUiLCJ5IiwieCIsInNhdmVXb3JsZCIsImxvY2FsU3RvcmFnZSIsInNldEl0ZW0iLCJKU09OIiwic3RyaW5naWZ5IiwiY2xlYXIiLCJyZW1vdmVJdGVtIiwiaW5pdCIsImNhbnZhc1dpZHRoIiwiY2FudmFzSGVpZ2h0IiwiTWF0aCIsImZsb29yIiwic2F2ZWRHcmlkIiwiZ2V0SXRlbSIsInBhcnNlZEdyaWQiLCJwYXJzZSIsImxlbmd0aCIsImUiLCJjb25zb2xlIiwiZXJyb3IiLCJBcnJheSIsImZpbGwiLCJtYXAiLCJnZXRHcmlkIiwiZ2V0Q2VsbFNpemUiLCJzZXRFbGVtZW50IiwiZWxlbWVudFR5cGUiLCJicnVzaFNpemUiLCJyYWRpdXMiLCJpIiwiaiIsIm5ld1giLCJuZXdZIiwibW92ZSIsIngxIiwieTEiLCJ4MiIsInkyIiwidGVtcCIsImlzV2l0aGluQm91bmRzIiwiaXNFbXB0eSIsImlzIiwic2V0IiwidXBkYXRlIiwidXBkYXRlZFBvc2l0aW9ucyIsIlNldCIsInVwZGF0ZUVsZW1lbnQiLCJwb3MiLCJoYXMiLCJlbGVtZW50IiwicmFuZG9tIiwiZGlyIiwiYWRkIiwiZGVuc2l0eSIsImJlbG93IiwidW5kZWZpbmVkIiwiZGlhZzEiLCJkaWFnMiIsImlzU2xvdyIsIm5laWdoYm9yIiwiaXNTdGFibGUiLCJncm93WCIsImdyb3dZIiwic2NhbkRpcmVjdGlvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/simulation/world.ts\n"));

/***/ })

});