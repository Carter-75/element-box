"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/app/simulation/world.ts":
/*!*************************************!*\
  !*** ./src/app/simulation/world.ts ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DENSITIES: function() { return /* binding */ DENSITIES; },\n/* harmony export */   ELEMENT_COLORS: function() { return /* binding */ ELEMENT_COLORS; },\n/* harmony export */   ELEMENT_TYPE: function() { return /* binding */ ELEMENT_TYPE; },\n/* harmony export */   clear: function() { return /* binding */ clear; },\n/* harmony export */   getCellSize: function() { return /* binding */ getCellSize; },\n/* harmony export */   getGrid: function() { return /* binding */ getGrid; },\n/* harmony export */   init: function() { return /* binding */ init; },\n/* harmony export */   saveWorld: function() { return /* binding */ saveWorld; },\n/* harmony export */   setElement: function() { return /* binding */ setElement; },\n/* harmony export */   setWalls: function() { return /* binding */ setWalls; },\n/* harmony export */   update: function() { return /* binding */ update; }\n/* harmony export */ });\nconst ELEMENT_TYPE = {\n    EMPTY: 0,\n    WALL: 1,\n    SAND: 2,\n    WATER: 3,\n    PLANT: 4,\n    FIRE: 5,\n    LAVA: 6,\n    ACID: 7,\n    SMOKE: 8,\n    STONE: 9,\n    STONE_ASH: 10,\n    ASH: 11,\n    HOT_ASH: 12\n};\nconst ELEMENT_COLORS = {\n    [ELEMENT_TYPE.EMPTY]: \"#000000\",\n    [ELEMENT_TYPE.WALL]: \"#505050\",\n    [ELEMENT_TYPE.SAND]: \"#f0d9a5\",\n    [ELEMENT_TYPE.WATER]: \"#3498db\",\n    [ELEMENT_TYPE.PLANT]: \"#2ecc71\",\n    [ELEMENT_TYPE.FIRE]: \"#e74c3c\",\n    [ELEMENT_TYPE.LAVA]: \"#d35400\",\n    [ELEMENT_TYPE.ACID]: \"#9b59b6\",\n    [ELEMENT_TYPE.SMOKE]: \"#888888\",\n    [ELEMENT_TYPE.STONE]: \"#808080\",\n    [ELEMENT_TYPE.STONE_ASH]: \"#6b6b6b\",\n    [ELEMENT_TYPE.ASH]: \"#2b2b2b\",\n    [ELEMENT_TYPE.HOT_ASH]: \"#db4f27\"\n};\nconst DENSITIES = {\n    [ELEMENT_TYPE.EMPTY]: 0,\n    [ELEMENT_TYPE.SMOKE]: 1,\n    [ELEMENT_TYPE.FIRE]: 1,\n    [ELEMENT_TYPE.WATER]: 10,\n    [ELEMENT_TYPE.ACID]: 11,\n    [ELEMENT_TYPE.ASH]: 12,\n    [ELEMENT_TYPE.HOT_ASH]: 12,\n    [ELEMENT_TYPE.SAND]: 15,\n    [ELEMENT_TYPE.PLANT]: 20,\n    [ELEMENT_TYPE.STONE_ASH]: 22,\n    [ELEMENT_TYPE.LAVA]: 25,\n    [ELEMENT_TYPE.STONE]: 30,\n    [ELEMENT_TYPE.WALL]: Infinity\n};\nconst LOCAL_STORAGE_KEY = \"sandSimulationGrid\";\nconst CELL_SIZE = 5;\nlet width, height;\nlet grid;\nlet areWallsOn = true;\nconst setWalls = (enabled)=>{\n    areWallsOn = enabled;\n    const wallType = enabled ? ELEMENT_TYPE.WALL : ELEMENT_TYPE.EMPTY;\n    if (!grid) return;\n    for(let y = 0; y < height; y++){\n        if (grid[y]) {\n            grid[y][0] = wallType;\n            grid[y][width - 1] = wallType;\n        }\n    }\n    for(let x = 0; x < width; x++){\n        if (grid[0]) grid[0][x] = wallType;\n        if (grid[height - 1]) grid[height - 1][x] = wallType;\n    }\n};\nconst saveWorld = ()=>{\n    if (grid) {\n        localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(grid));\n    }\n};\nconst clear = ()=>{\n    for(let y = 0; y < height; y++){\n        for(let x = 0; x < width; x++){\n            grid[y][x] = ELEMENT_TYPE.EMPTY;\n        }\n    }\n    if (areWallsOn) {\n        setWalls(true);\n    }\n    localStorage.removeItem(LOCAL_STORAGE_KEY);\n};\nconst init = (canvasWidth, canvasHeight)=>{\n    width = Math.floor(canvasWidth / CELL_SIZE);\n    height = Math.floor(canvasHeight / CELL_SIZE);\n    const savedGrid = localStorage.getItem(LOCAL_STORAGE_KEY);\n    if (savedGrid) {\n        try {\n            const parsedGrid = JSON.parse(savedGrid);\n            if (parsedGrid && parsedGrid.length === height && parsedGrid[0].length === width) {\n                grid = parsedGrid;\n                return;\n            }\n        } catch (e) {\n            console.error(\"Failed to parse saved grid:\", e);\n        }\n    }\n    grid = Array(height).fill(0).map(()=>Array(width).fill(ELEMENT_TYPE.EMPTY));\n    setWalls(areWallsOn);\n};\nconst getGrid = ()=>grid;\nconst getCellSize = ()=>CELL_SIZE;\nconst setElement = (x, y, elementType, brushSize)=>{\n    const radius = Math.floor(brushSize / CELL_SIZE / 2);\n    for(let i = -radius; i <= radius; i++){\n        for(let j = -radius; j <= radius; j++){\n            if (i * i + j * j <= radius * radius) {\n                const newX = x + i;\n                const newY = y + j;\n                if (newX >= 0 && newX < width && newY >= 0 && newY < height) {\n                    if (grid[newY][newX] === ELEMENT_TYPE.EMPTY || elementType === ELEMENT_TYPE.EMPTY) {\n                        grid[newY][newX] = elementType;\n                    }\n                }\n            }\n        }\n    }\n};\nconst move = (x1, y1, x2, y2)=>{\n    const temp = grid[y1][x1];\n    grid[y1][x1] = grid[y2][x2];\n    grid[y2][x2] = temp;\n};\nconst isWithinBounds = (x, y)=>{\n    return y >= 0 && y < height && x >= 0 && x < width;\n};\nconst isEmpty = (x, y)=>{\n    return isWithinBounds(x, y) && grid[y][x] === ELEMENT_TYPE.EMPTY;\n};\nconst is = (x, y, elementType)=>{\n    return isWithinBounds(x, y) && grid[y][x] === elementType;\n};\nconst set = (x, y, elementType)=>{\n    if (isWithinBounds(x, y)) {\n        grid[y][x] = elementType;\n    }\n};\nconst update = ()=>{\n    const updatedPositions = new Set();\n    const updateElement = (x, y)=>{\n        const pos = \"\".concat(x, \",\").concat(y);\n        if (updatedPositions.has(pos)) {\n            return; // Already updated in this frame\n        }\n        const element = grid[y][x];\n        // --- Out of Bounds Check ---\n        if (!areWallsOn) {\n            if (y <= 0 && (element === ELEMENT_TYPE.FIRE || element === ELEMENT_TYPE.SMOKE)) {\n                set(x, y, ELEMENT_TYPE.EMPTY);\n                return;\n            }\n            if (y >= height - 1 && DENSITIES[element] > DENSITIES[ELEMENT_TYPE.EMPTY]) {\n                set(x, y, ELEMENT_TYPE.EMPTY);\n                return;\n            }\n        }\n        // --- Movement Phase ---\n        // A particle will attempt to move, and if it does, its turn ends.\n        // Interactions only happen if a particle cannot move.\n        // Gas Movement (Up)\n        if (element === ELEMENT_TYPE.FIRE || element === ELEMENT_TYPE.SMOKE) {\n            const dir = Math.random() < 0.5 ? -1 : 1;\n            // Up\n            if (isEmpty(x, y - 1)) {\n                move(x, y, x, y - 1);\n                updatedPositions.add(\"\".concat(x, \",\").concat(y - 1));\n                return;\n            }\n            // Diagonal Up\n            if (isEmpty(x + dir, y - 1)) {\n                move(x, y, x + dir, y - 1);\n                updatedPositions.add(\"\".concat(x + dir, \",\").concat(y - 1));\n                return;\n            }\n            // Sideways\n            if (isEmpty(x + dir, y)) {\n                move(x, y, x + dir, y);\n                updatedPositions.add(\"\".concat(x + dir, \",\").concat(y));\n                return;\n            }\n        } else if (DENSITIES[element] > DENSITIES[ELEMENT_TYPE.EMPTY] && DENSITIES[element] < DENSITIES[ELEMENT_TYPE.WALL]) {\n            var _grid_, _grid_1, _grid_2;\n            const density = DENSITIES[element];\n            // Down\n            const below = (_grid_ = grid[y + 1]) === null || _grid_ === void 0 ? void 0 : _grid_[x];\n            if (below !== undefined && density > DENSITIES[below]) {\n                move(x, y, x, y + 1);\n                updatedPositions.add(\"\".concat(x, \",\").concat(y + 1));\n                return;\n            }\n            // Diagonal Down\n            const dir = Math.random() < 0.5 ? -1 : 1;\n            const diag1 = (_grid_1 = grid[y + 1]) === null || _grid_1 === void 0 ? void 0 : _grid_1[x + dir];\n            if (diag1 !== undefined && density > DENSITIES[diag1]) {\n                move(x, y, x + dir, y + 1);\n                updatedPositions.add(\"\".concat(x + dir, \",\").concat(y + 1));\n                return;\n            }\n            const diag2 = (_grid_2 = grid[y + 1]) === null || _grid_2 === void 0 ? void 0 : _grid_2[x - dir];\n            if (diag2 !== undefined && density > DENSITIES[diag2]) {\n                move(x, y, x - dir, y + 1);\n                updatedPositions.add(\"\".concat(x - dir, \",\").concat(y + 1));\n                return;\n            }\n            // Sideways (Liquids Only)\n            if (element === ELEMENT_TYPE.WATER || element === ELEMENT_TYPE.ACID || element === ELEMENT_TYPE.LAVA) {\n                const isSlow = element === ELEMENT_TYPE.LAVA && Math.random() < 0.5;\n                if (!isSlow) {\n                    if (isEmpty(x + dir, y)) {\n                        move(x, y, x + dir, y);\n                        updatedPositions.add(\"\".concat(x + dir, \",\").concat(y));\n                        return;\n                    }\n                    if (isEmpty(x - dir, y)) {\n                        move(x, y, x - dir, y);\n                        updatedPositions.add(\"\".concat(x - dir, \",\").concat(y));\n                        return;\n                    }\n                }\n            }\n        }\n        // --- Interaction Phase ---\n        // This code only runs if the particle did not move in the movement phase.\n        switch(element){\n            case ELEMENT_TYPE.LAVA:\n            case ELEMENT_TYPE.ACID:\n                for(let i = -1; i <= 1; i++){\n                    for(let j = -1; j <= 1; j++){\n                        var _grid_3;\n                        if (i === 0 && j === 0) continue;\n                        const neighbor = (_grid_3 = grid[y + j]) === null || _grid_3 === void 0 ? void 0 : _grid_3[x + i];\n                        if (neighbor === undefined || neighbor === ELEMENT_TYPE.WALL || neighbor === element) continue;\n                        if (is(x + i, y + j, ELEMENT_TYPE.LAVA) && element === ELEMENT_TYPE.ACID) {\n                            set(x + i, y + j, ELEMENT_TYPE.SMOKE);\n                            set(x, y, ELEMENT_TYPE.SMOKE);\n                        } else if (neighbor !== ELEMENT_TYPE.EMPTY) {\n                            set(x + i, y + j, ELEMENT_TYPE.FIRE);\n                            if (element === ELEMENT_TYPE.ACID && Math.random() < 0.2) {\n                                set(x, y, ELEMENT_TYPE.EMPTY);\n                            }\n                        }\n                    }\n                }\n                break;\n            case ELEMENT_TYPE.FIRE:\n                if (Math.random() < 0.05) {\n                    set(x, y, ELEMENT_TYPE.HOT_ASH);\n                }\n                break;\n            case ELEMENT_TYPE.HOT_ASH:\n                if (Math.random() < 0.05) {\n                    set(x, y, ELEMENT_TYPE.ASH);\n                    break;\n                }\n                for(let i = -1; i <= 1; i++){\n                    for(let j = -1; j <= 1; j++){\n                        var _grid_4;\n                        if (i === 0 && j === 0) continue;\n                        const neighbor = (_grid_4 = grid[y + j]) === null || _grid_4 === void 0 ? void 0 : _grid_4[x + i];\n                        if (neighbor === ELEMENT_TYPE.WATER) {\n                            set(x, y, ELEMENT_TYPE.ASH);\n                            set(x + i, y + j, ELEMENT_TYPE.SMOKE);\n                        } else if (neighbor !== ELEMENT_TYPE.ASH && neighbor !== ELEMENT_TYPE.HOT_ASH && DENSITIES[neighbor] > 0 && DENSITIES[neighbor] < DENSITIES[ELEMENT_TYPE.LAVA]) {\n                            if (Math.random() < 0.05) {\n                                set(x + i, y + j, ELEMENT_TYPE.FIRE);\n                                set(x, y, ELEMENT_TYPE.ASH);\n                            }\n                        }\n                    }\n                }\n                break;\n            case ELEMENT_TYPE.STONE_ASH:\n                var _grid_5;\n                const isStable = DENSITIES[(_grid_5 = grid[y + 1]) === null || _grid_5 === void 0 ? void 0 : _grid_5[x]] >= DENSITIES[ELEMENT_TYPE.STONE_ASH];\n                if (isStable && Math.random() < 0.01) {\n                    set(x, y, ELEMENT_TYPE.STONE);\n                }\n                break;\n            case ELEMENT_TYPE.PLANT:\n                if (Math.random() < 0.05) {\n                    for(let i = -1; i <= 1; i++){\n                        for(let j = -1; j <= 1; j++){\n                            if (is(x + i, y + j, ELEMENT_TYPE.WATER)) {\n                                // Try to grow into an empty space nearby\n                                const growX = x - i;\n                                const growY = y - j;\n                                if (isEmpty(growX, growY)) {\n                                    set(growX, growY, ELEMENT_TYPE.PLANT);\n                                }\n                            }\n                        }\n                    }\n                }\n                break;\n        }\n        updatedPositions.add(pos);\n    };\n    // Iterate through the grid and update elements\n    for(let y = height - 2; y > 0; y--){\n        const scanDirection = Math.random() < 0.5 ? 1 : -1;\n        if (scanDirection === 1) {\n            for(let x = 1; x < width - 1; x++){\n                updateElement(x, y);\n            }\n        } else {\n            for(let x = width - 2; x > 0; x--){\n                updateElement(x, y);\n            }\n        }\n    }\n    // Process solids (non-moving but interactive elements)\n    for(let y = 0; y < height; y++){\n        for(let x = 0; x < width; x++){\n            if (grid[y][x] === ELEMENT_TYPE.PLANT) {\n                updateElement(x, y);\n            }\n        }\n    }\n    // Iterate top-to-bottom for rising particles\n    for(let y = 0; y < height; y++){\n        for(let x = 0; x < width; x++){\n            if (grid[y][x] === ELEMENT_TYPE.SMOKE || grid[y][x] === ELEMENT_TYPE.FIRE) {\n                updateElement(x, y);\n            }\n        }\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvc2ltdWxhdGlvbi93b3JsZC50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFPLE1BQU1BLGVBQWU7SUFDMUJDLE9BQU87SUFDUEMsTUFBTTtJQUNOQyxNQUFNO0lBQ05DLE9BQU87SUFDUEMsT0FBTztJQUNQQyxNQUFNO0lBQ05DLE1BQU07SUFDTkMsTUFBTTtJQUNOQyxPQUFPO0lBQ1BDLE9BQU87SUFDUEMsV0FBVztJQUNYQyxLQUFLO0lBQ0xDLFNBQVM7QUFDWCxFQUFXO0FBSUosTUFBTUMsaUJBQThDO0lBQ3ZELENBQUNkLGFBQWFDLEtBQUssQ0FBQyxFQUFFO0lBQ3RCLENBQUNELGFBQWFFLElBQUksQ0FBQyxFQUFFO0lBQ3JCLENBQUNGLGFBQWFHLElBQUksQ0FBQyxFQUFFO0lBQ3JCLENBQUNILGFBQWFJLEtBQUssQ0FBQyxFQUFFO0lBQ3RCLENBQUNKLGFBQWFLLEtBQUssQ0FBQyxFQUFFO0lBQ3RCLENBQUNMLGFBQWFNLElBQUksQ0FBQyxFQUFFO0lBQ3JCLENBQUNOLGFBQWFPLElBQUksQ0FBQyxFQUFFO0lBQ3JCLENBQUNQLGFBQWFRLElBQUksQ0FBQyxFQUFFO0lBQ3JCLENBQUNSLGFBQWFTLEtBQUssQ0FBQyxFQUFFO0lBQ3RCLENBQUNULGFBQWFVLEtBQUssQ0FBQyxFQUFFO0lBQ3RCLENBQUNWLGFBQWFXLFNBQVMsQ0FBQyxFQUFFO0lBQzFCLENBQUNYLGFBQWFZLEdBQUcsQ0FBQyxFQUFFO0lBQ3BCLENBQUNaLGFBQWFhLE9BQU8sQ0FBQyxFQUFFO0FBQzVCLEVBQUU7QUFFSyxNQUFNRSxZQUF5QztJQUNsRCxDQUFDZixhQUFhQyxLQUFLLENBQUMsRUFBRTtJQUN0QixDQUFDRCxhQUFhUyxLQUFLLENBQUMsRUFBRTtJQUN0QixDQUFDVCxhQUFhTSxJQUFJLENBQUMsRUFBRTtJQUNyQixDQUFDTixhQUFhSSxLQUFLLENBQUMsRUFBRTtJQUN0QixDQUFDSixhQUFhUSxJQUFJLENB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TSxLQUFLLE1BQU0sSUFBSSxDQUFDO1FBQ2pELElBQUlZLGtCQUFrQixHQUFHO1lBQ3JCLElBQUssSUFBSWhFLElBQUksR0FBR0EsSUFBSVIsUUFBUSxHQUFHUSxJQUFLO2dCQUNoQytDLGNBQWMvQyxHQUFHRDtZQUNyQjtRQUNKLE9BQU87WUFDSCxJQUFLLElBQUlDLElBQUlSLFFBQVEsR0FBR1EsSUFBSSxHQUFHQSxJQUFLO2dCQUNoQytDLGNBQWMvQyxHQUFHRDtZQUNyQjtRQUNKO0lBQ0o7SUFFQSx1REFBdUQ7SUFDdkQsSUFBSyxJQUFJQSxJQUFJLEdBQUdBLElBQUlOLFFBQVFNLElBQUs7UUFDN0IsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlSLE9BQU9RLElBQUs7WUFDM0IsSUFBSU4sSUFBSSxDQUFDSyxFQUFFLENBQUNDLEVBQUUsS0FBSzNCLGFBQWFLLEtBQUssRUFBRTtnQkFDbkNxRSxjQUFjL0MsR0FBR0Q7WUFDdEI7UUFDSjtJQUNKO0lBRUEsNkNBQTZDO0lBQzdDLElBQUssSUFBSUEsSUFBSSxHQUFHQSxJQUFJTixRQUFRTSxJQUFLO1FBQzdCLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJUixPQUFPUSxJQUFLO1lBQzNCLElBQUlOLElBQUksQ0FBQ0ssRUFBRSxDQUFDQyxFQUFFLEtBQUszQixhQUFhUyxLQUFLLElBQUlZLElBQUksQ0FBQ0ssRUFBRSxDQUFDQyxFQUFFLEtBQUszQixhQUFhTSxJQUFJLEVBQUU7Z0JBQ3ZFb0UsY0FBYy9DLEdBQUdEO1lBQ3RCO1FBQ0o7SUFDSjtBQUNKLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2FwcC9zaW11bGF0aW9uL3dvcmxkLnRzPzY1NTYiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IEVMRU1FTlRfVFlQRSA9IHtcclxuICBFTVBUWTogMCxcclxuICBXQUxMOiAxLFxyXG4gIFNBTkQ6IDIsXHJcbiAgV0FURVI6IDMsXHJcbiAgUExBTlQ6IDQsXHJcbiAgRklSRTogNSxcclxuICBMQVZBOiA2LFxyXG4gIEFDSUQ6IDcsXHJcbiAgU01PS0U6IDgsXHJcbiAgU1RPTkU6IDksXHJcbiAgU1RPTkVfQVNIOiAxMCxcclxuICBBU0g6IDExLFxyXG4gIEhPVF9BU0g6IDEyLFxyXG59IGFzIGNvbnN0O1xyXG5cclxuZXhwb3J0IHR5cGUgRWxlbWVudFR5cGUgPSB0eXBlb2YgRUxFTUVOVF9UWVBFW2tleW9mIHR5cGVvZiBFTEVNRU5UX1RZUEVdO1xyXG5cclxuZXhwb3J0IGNvbnN0IEVMRU1FTlRfQ09MT1JTOiBSZWNvcmQ8RWxlbWVudFR5cGUsIHN0cmluZz4gPSB7XHJcbiAgICBbRUxFTUVOVF9UWVBFLkVNUFRZXTogJyMwMDAwMDAnLFxyXG4gICAgW0VMRU1FTlRfVFlQRS5XQUxMXTogJyM1MDUwNTAnLFxyXG4gICAgW0VMRU1FTlRfVFlQRS5TQU5EXTogJyNmMGQ5YTUnLFxyXG4gICAgW0VMRU1FTlRfVFlQRS5XQVRFUl06ICcjMzQ5OGRiJyxcclxuICAgIFtFTEVNRU5UX1RZUEUuUExBTlRdOiAnIzJlY2M3MScsXHJcbiAgICBbRUxFTUVOVF9UWVBFLkZJUkVdOiAnI2U3NGMzYycsXHJcbiAgICBbRUxFTUVOVF9UWVBFLkxBVkFdOiAnI2QzNTQwMCcsXHJcbiAgICBbRUxFTUVOVF9UWVBFLkFDSURdOiAnIzliNTliNicsXHJcbiAgICBbRUxFTUVOVF9UWVBFLlNNT0tFXTogJyM4ODg4ODgnLFxyXG4gICAgW0VMRU1FTlRfVFlQRS5TVE9ORV06ICcjODA4MDgwJyxcclxuICAgIFtFTEVNRU5UX1RZUEUuU1RPTkVfQVNIXTogJyM2YjZiNmInLFxyXG4gICAgW0VMRU1FTlRfVFlQRS5BU0hdOiAnIzJiMmIyYicsXHJcbiAgICBbRUxFTUVOVF9UWVBFLkhPVF9BU0hdOiAnI2RiNGYyNycsXHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgREVOU0lUSUVTOiBSZWNvcmQ8RWxlbWVudFR5cGUsIG51bWJlcj4gPSB7XHJcbiAgICBbRUxFTUVOVF9UWVBFLkVNUFRZXTogMCxcclxuICAgIFtFTEVNRU5UX1RZUEUuU01PS0VdOiAxLFxyXG4gICAgW0VMRU1FTlRfVFlQRS5GSVJFXTogMSxcclxuICAgIFtFTEVNRU5UX1RZUEUuV0FURVJdOiAxMCxcclxuICAgIFtFTEVNRU5UX1RZUEUuQUNJRF06IDExLFxyXG4gICAgW0VMRU1FTlRfVFlQRS5BU0hdOiAxMixcclxuICAgIFtFTEVNRU5UX1RZUEUuSE9UX0FTSF06IDEyLFxyXG4gICAgW0VMRU1FTlRfVFlQRS5TQU5EXTogMTUsXHJcbiAgICBbRUxFTUVOVF9UWVBFLlBMQU5UXTogMjAsXHJcbiAgICBbRUxFTUVOVF9UWVBFLlNUT05FX0FTSF06IDIyLFxyXG4gICAgW0VMRU1FTlRfVFlQRS5MQVZBXTogMjUsXHJcbiAgICBbRUxFTUVOVF9UWVBFLlNUT05FXTogMzAsXHJcbiAgICBbRUxFTUVOVF9UWVBFLldBTExdOiBJbmZpbml0eSxcclxufTtcclxuXHJcbmNvbnN0IExPQ0FMX1NUT1JBR0VfS0VZID0gJ3NhbmRTaW11bGF0aW9uR3JpZCc7XHJcbmNvbnN0IENFTExfU0laRSA9IDU7XHJcbmxldCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcjtcclxubGV0IGdyaWQ6IEVsZW1lbnRUeXBlW11bXTtcclxubGV0IGFyZVdhbGxzT24gPSB0cnVlO1xyXG5cclxuZXhwb3J0IGNvbnN0IHNldFdhbGxzID0gKGVuYWJsZWQ6IGJvb2xlYW4pID0+IHtcclxuICAgIGFyZVdhbGxzT24gPSBlbmFibGVkO1xyXG4gICAgY29uc3Qgd2FsbFR5cGUgPSBlbmFibGVkID8gRUxFTUVOVF9UWVBFLldBTEwgOiBFTEVNRU5UX1RZUEUuRU1QVFk7XHJcblxyXG4gICAgaWYgKCFncmlkKSByZXR1cm47XHJcblxyXG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKykge1xyXG4gICAgICAgIGlmIChncmlkW3ldKSB7XHJcbiAgICAgICAgICAgIGdyaWRbeV1bMF0gPSB3YWxsVHlwZTtcclxuICAgICAgICAgICAgZ3JpZFt5XVt3aWR0aCAtIDFdID0gd2FsbFR5cGU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZm9yIChsZXQgeCA9IDA7IHggPCB3aWR0aDsgeCsrKSB7XHJcbiAgICAgICAgaWYgKGdyaWRbMF0pIGdyaWRbMF1beF0gPSB3YWxsVHlwZTtcclxuICAgICAgICBpZiAoZ3JpZFtoZWlnaHQgLSAxXSkgZ3JpZFtoZWlnaHQgLSAxXVt4XSA9IHdhbGxUeXBlO1xyXG4gICAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHNhdmVXb3JsZCA9ICgpID0+IHtcclxuICAgIGlmIChncmlkKSB7XHJcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oTE9DQUxfU1RPUkFHRV9LRVksIEpTT04uc3RyaW5naWZ5KGdyaWQpKTtcclxuICAgIH1cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBjbGVhciA9ICgpID0+IHtcclxuICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHtcclxuICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHdpZHRoOyB4KyspIHtcclxuICAgICAgICAgICAgZ3JpZFt5XVt4XSA9IEVMRU1FTlRfVFlQRS5FTVBUWTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoYXJlV2FsbHNPbikge1xyXG4gICAgICAgIHNldFdhbGxzKHRydWUpO1xyXG4gICAgfVxyXG4gICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oTE9DQUxfU1RPUkFHRV9LRVkpO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGluaXQgPSAoY2FudmFzV2lkdGg6IG51bWJlciwgY2FudmFzSGVpZ2h0OiBudW1iZXIpID0+IHtcclxuICAgIHdpZHRoID0gTWF0aC5mbG9vcihjYW52YXNXaWR0aCAvIENFTExfU0laRSk7XHJcbiAgICBoZWlnaHQgPSBNYXRoLmZsb29yKGNhbnZhc0hlaWdodCAvIENFTExfU0laRSk7XHJcblxyXG4gICAgY29uc3Qgc2F2ZWRHcmlkID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oTE9DQUxfU1RPUkFHRV9LRVkpO1xyXG4gICAgXHJcbiAgICBpZiAoc2F2ZWRHcmlkKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3QgcGFyc2VkR3JpZCA9IEpTT04ucGFyc2Uoc2F2ZWRHcmlkKTtcclxuICAgICAgICAgICAgaWYgKHBhcnNlZEdyaWQgJiYgcGFyc2VkR3JpZC5sZW5ndGggPT09IGhlaWdodCAmJiBwYXJzZWRHcmlkWzBdLmxlbmd0aCA9PT0gd2lkdGgpIHtcclxuICAgICAgICAgICAgICAgIGdyaWQgPSBwYXJzZWRHcmlkO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIHBhcnNlIHNhdmVkIGdyaWQ6XCIsIGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBncmlkID0gQXJyYXkoaGVpZ2h0KS5maWxsKDApLm1hcCgoKSA9PiBBcnJheSh3aWR0aCkuZmlsbChFTEVNRU5UX1RZUEUuRU1QVFkpKTtcclxuICAgIHNldFdhbGxzKGFyZVdhbGxzT24pO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGdldEdyaWQgPSAoKSA9PiBncmlkO1xyXG5leHBvcnQgY29uc3QgZ2V0Q2VsbFNpemUgPSAoKSA9PiBDRUxMX1NJWkU7XHJcblxyXG5leHBvcnQgY29uc3Qgc2V0RWxlbWVudCA9ICh4OiBudW1iZXIsIHk6IG51bWJlciwgZWxlbWVudFR5cGU6IEVsZW1lbnRUeXBlLCBicnVzaFNpemU6IG51bWJlcikgPT4ge1xyXG4gICAgY29uc3QgcmFkaXVzID0gTWF0aC5mbG9vcihicnVzaFNpemUgLyBDRUxMX1NJWkUgLyAyKTtcclxuICAgIGZvciAobGV0IGkgPSAtcmFkaXVzOyBpIDw9IHJhZGl1czsgaSsrKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaiA9IC1yYWRpdXM7IGogPD0gcmFkaXVzOyBqKyspIHtcclxuICAgICAgICAgICAgaWYgKGkqaSArIGoqaiA8PSByYWRpdXMqcmFkaXVzKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdYID0geCArIGk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdZID0geSArIGo7XHJcbiAgICAgICAgICAgICAgICBpZiAobmV3WCA+PSAwICYmIG5ld1ggPCB3aWR0aCAmJiBuZXdZID49IDAgJiYgbmV3WSA8IGhlaWdodCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChncmlkW25ld1ldW25ld1hdID09PSBFTEVNRU5UX1RZUEUuRU1QVFkgfHwgZWxlbWVudFR5cGUgPT09IEVMRU1FTlRfVFlQRS5FTVBUWSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBncmlkW25ld1ldW25ld1hdID0gZWxlbWVudFR5cGU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxuY29uc3QgbW92ZSA9ICh4MTogbnVtYmVyLCB5MTogbnVtYmVyLCB4MjogbnVtYmVyLCB5MjogbnVtYmVyKSA9PiB7XHJcbiAgICBjb25zdCB0ZW1wID0gZ3JpZFt5MV1beDFdO1xyXG4gICAgZ3JpZFt5MV1beDFdID0gZ3JpZFt5Ml1beDJdO1xyXG4gICAgZ3JpZFt5Ml1beDJdID0gdGVtcDtcclxufVxyXG5cclxuY29uc3QgaXNXaXRoaW5Cb3VuZHMgPSAoeDogbnVtYmVyLCB5OiBudW1iZXIpID0+IHtcclxuICAgIHJldHVybiB5ID49IDAgJiYgeSA8IGhlaWdodCAmJiB4ID49IDAgJiYgeCA8IHdpZHRoO1xyXG59XHJcblxyXG5jb25zdCBpc0VtcHR5ID0gKHg6IG51bWJlciwgeTogbnVtYmVyKSA9PiB7XHJcbiAgICByZXR1cm4gaXNXaXRoaW5Cb3VuZHMoeCwgeSkgJiYgZ3JpZFt5XVt4XSA9PT0gRUxFTUVOVF9UWVBFLkVNUFRZO1xyXG59XHJcblxyXG5jb25zdCBpcyA9ICh4OiBudW1iZXIsIHk6IG51bWJlciwgZWxlbWVudFR5cGU6IEVsZW1lbnRUeXBlKSA9PiB7XHJcbiAgICByZXR1cm4gaXNXaXRoaW5Cb3VuZHMoeCwgeSkgJiYgZ3JpZFt5XVt4XSA9PT0gZWxlbWVudFR5cGU7XHJcbn1cclxuXHJcbmNvbnN0IHNldCA9ICh4OiBudW1iZXIsIHk6IG51bWJlciwgZWxlbWVudFR5cGU6IEVsZW1lbnRUeXBlKSA9PiB7XHJcbiAgICBpZiAoaXNXaXRoaW5Cb3VuZHMoeCwgeSkpIHtcclxuICAgICAgICBncmlkW3ldW3hdID0gZWxlbWVudFR5cGU7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCB1cGRhdGUgPSAoKSA9PiB7XHJcbiAgICBjb25zdCB1cGRhdGVkUG9zaXRpb25zID0gbmV3IFNldDxzdHJpbmc+KCk7XHJcblxyXG4gICAgY29uc3QgdXBkYXRlRWxlbWVudCA9ICh4OiBudW1iZXIsIHk6IG51bWJlcikgPT4ge1xyXG4gICAgICAgIGNvbnN0IHBvcyA9IGAke3h9LCR7eX1gO1xyXG4gICAgICAgIGlmICh1cGRhdGVkUG9zaXRpb25zLmhhcyhwb3MpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjsgLy8gQWxyZWFkeSB1cGRhdGVkIGluIHRoaXMgZnJhbWVcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBncmlkW3ldW3hdO1xyXG5cclxuICAgICAgICAvLyAtLS0gT3V0IG9mIEJvdW5kcyBDaGVjayAtLS1cclxuICAgICAgICBpZiAoIWFyZVdhbGxzT24pIHtcclxuICAgICAgICAgICAgaWYgKHkgPD0gMCAmJiAoZWxlbWVudCA9PT0gRUxFTUVOVF9UWVBFLkZJUkUgfHwgZWxlbWVudCA9PT0gRUxFTUVOVF9UWVBFLlNNT0tFKSkge1xyXG4gICAgICAgICAgICAgICAgc2V0KHgsIHksIEVMRU1FTlRfVFlQRS5FTVBUWSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHkgPj0gaGVpZ2h0IC0gMSAmJiBERU5TSVRJRVNbZWxlbWVudF0gPiBERU5TSVRJRVNbRUxFTUVOVF9UWVBFLkVNUFRZXSkge1xyXG4gICAgICAgICAgICAgICAgIHNldCh4LCB5LCBFTEVNRU5UX1RZUEUuRU1QVFkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyAtLS0gTW92ZW1lbnQgUGhhc2UgLS0tXHJcbiAgICAgICAgLy8gQSBwYXJ0aWNsZSB3aWxsIGF0dGVtcHQgdG8gbW92ZSwgYW5kIGlmIGl0IGRvZXMsIGl0cyB0dXJuIGVuZHMuXHJcbiAgICAgICAgLy8gSW50ZXJhY3Rpb25zIG9ubHkgaGFwcGVuIGlmIGEgcGFydGljbGUgY2Fubm90IG1vdmUuXHJcblxyXG4gICAgICAgIC8vIEdhcyBNb3ZlbWVudCAoVXApXHJcbiAgICAgICAgaWYgKGVsZW1lbnQgPT09IEVMRU1FTlRfVFlQRS5GSVJFIHx8IGVsZW1lbnQgPT09IEVMRU1FTlRfVFlQRS5TTU9LRSkge1xyXG4gICAgICAgICAgICBjb25zdCBkaXIgPSBNYXRoLnJhbmRvbSgpIDwgMC41ID8gLTEgOiAxO1xyXG4gICAgICAgICAgICAvLyBVcFxyXG4gICAgICAgICAgICBpZiAoaXNFbXB0eSh4LCB5IC0gMSkpIHsgbW92ZSh4LCB5LCB4LCB5IC0gMSk7IHVwZGF0ZWRQb3NpdGlvbnMuYWRkKGAke3h9LCR7eS0xfWApOyByZXR1cm47IH1cclxuICAgICAgICAgICAgLy8gRGlhZ29uYWwgVXBcclxuICAgICAgICAgICAgaWYgKGlzRW1wdHkoeCArIGRpciwgeSAtIDEpKSB7IG1vdmUoeCwgeSwgeCArIGRpciwgeSAtIDEpOyB1cGRhdGVkUG9zaXRpb25zLmFkZChgJHt4K2Rpcn0sJHt5LTF9YCk7IHJldHVybjsgfVxyXG4gICAgICAgICAgICAvLyBTaWRld2F5c1xyXG4gICAgICAgICAgICBpZiAoaXNFbXB0eSh4ICsgZGlyLCB5KSkgeyBtb3ZlKHgsIHksIHggKyBkaXIsIHkpOyB1cGRhdGVkUG9zaXRpb25zLmFkZChgJHt4K2Rpcn0sJHt5fWApOyByZXR1cm47IH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gRmFsbGluZyBQYXJ0aWNsZSBNb3ZlbWVudCAoUG93ZGVycyAmIExpcXVpZHMpXHJcbiAgICAgICAgZWxzZSBpZiAoREVOU0lUSUVTW2VsZW1lbnRdID4gREVOU0lUSUVTW0VMRU1FTlRfVFlQRS5FTVBUWV0gJiYgREVOU0lUSUVTW2VsZW1lbnRdIDwgREVOU0lUSUVTW0VMRU1FTlRfVFlQRS5XQUxMXSkge1xyXG4gICAgICAgICAgICBjb25zdCBkZW5zaXR5ID0gREVOU0lUSUVTW2VsZW1lbnRdO1xyXG5cclxuICAgICAgICAgICAgLy8gRG93blxyXG4gICAgICAgICAgICBjb25zdCBiZWxvdyA9IGdyaWRbeSArIDFdPy5beF07XHJcbiAgICAgICAgICAgIGlmIChiZWxvdyAhPT0gdW5kZWZpbmVkICYmIGRlbnNpdHkgPiBERU5TSVRJRVNbYmVsb3ddKSB7XHJcbiAgICAgICAgICAgICAgICBtb3ZlKHgsIHksIHgsIHkgKyAxKTsgdXBkYXRlZFBvc2l0aW9ucy5hZGQoYCR7eH0sJHt5KzF9YCk7IHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gRGlhZ29uYWwgRG93blxyXG4gICAgICAgICAgICBjb25zdCBkaXIgPSBNYXRoLnJhbmRvbSgpIDwgMC41ID8gLTEgOiAxO1xyXG4gICAgICAgICAgICBjb25zdCBkaWFnMSA9IGdyaWRbeSArIDFdPy5beCArIGRpcl07XHJcbiAgICAgICAgICAgIGlmIChkaWFnMSAhPT0gdW5kZWZpbmVkICYmIGRlbnNpdHkgPiBERU5TSVRJRVNbZGlhZzFdKSB7XHJcbiAgICAgICAgICAgICAgICBtb3ZlKHgsIHksIHggKyBkaXIsIHkgKyAxKTsgdXBkYXRlZFBvc2l0aW9ucy5hZGQoYCR7eCtkaXJ9LCR7eSsxfWApOyByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgZGlhZzIgPSBncmlkW3kgKyAxXT8uW3ggLSBkaXJdO1xyXG4gICAgICAgICAgICBpZiAoZGlhZzIgIT09IHVuZGVmaW5lZCAmJiBkZW5zaXR5ID4gREVOU0lUSUVTW2RpYWcyXSkge1xyXG4gICAgICAgICAgICAgICAgbW92ZSh4LCB5LCB4IC0gZGlyLCB5ICsgMSk7IHVwZGF0ZWRQb3NpdGlvbnMuYWRkKGAke3gtZGlyfSwke3krMX1gKTsgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBTaWRld2F5cyAoTGlxdWlkcyBPbmx5KVxyXG4gICAgICAgICAgICBpZiAoZWxlbWVudCA9PT0gRUxFTUVOVF9UWVBFLldBVEVSIHx8IGVsZW1lbnQgPT09IEVMRU1FTlRfVFlQRS5BQ0lEIHx8IGVsZW1lbnQgPT09IEVMRU1FTlRfVFlQRS5MQVZBKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpc1Nsb3cgPSAoZWxlbWVudCA9PT0gRUxFTUVOVF9UWVBFLkxBVkEgJiYgTWF0aC5yYW5kb20oKSA8IDAuNSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzU2xvdykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0VtcHR5KHggKyBkaXIsIHkpKSB7IG1vdmUoeCwgeSwgeCArIGRpciwgeSk7IHVwZGF0ZWRQb3NpdGlvbnMuYWRkKGAke3grZGlyfSwke3l9YCk7IHJldHVybjsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0VtcHR5KHggLSBkaXIsIHkpKSB7IG1vdmUoeCwgeSwgeCAtIGRpciwgeSk7IHVwZGF0ZWRQb3NpdGlvbnMuYWRkKGAke3gtZGlyfSwke3l9YCk7IHJldHVybjsgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyAtLS0gSW50ZXJhY3Rpb24gUGhhc2UgLS0tXHJcbiAgICAgICAgLy8gVGhpcyBjb2RlIG9ubHkgcnVucyBpZiB0aGUgcGFydGljbGUgZGlkIG5vdCBtb3ZlIGluIHRoZSBtb3ZlbWVudCBwaGFzZS5cclxuICAgICAgICBzd2l0Y2goZWxlbWVudCkge1xyXG4gICAgICAgICAgICBjYXNlIEVMRU1FTlRfVFlQRS5MQVZBOlxyXG4gICAgICAgICAgICBjYXNlIEVMRU1FTlRfVFlQRS5BQ0lEOlxyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IC0xOyBpIDw9IDE7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAtMTsgaiA8PSAxOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT09IDAgJiYgaiA9PT0gMCkgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5laWdoYm9yID0gZ3JpZFt5ICsgal0/Llt4ICsgaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZWlnaGJvciA9PT0gdW5kZWZpbmVkIHx8IG5laWdoYm9yID09PSBFTEVNRU5UX1RZUEUuV0FMTCB8fCBuZWlnaGJvciA9PT0gZWxlbWVudCkgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXMoeCArIGksIHkgKyBqLCBFTEVNRU5UX1RZUEUuTEFWQSkgJiYgZWxlbWVudCA9PT0gRUxFTUVOVF9UWVBFLkFDSUQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldCh4ICsgaSwgeSArIGosIEVMRU1FTlRfVFlQRS5TTU9LRSk7IHNldCh4LCB5LCBFTEVNRU5UX1RZUEUuU01PS0UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5laWdoYm9yICE9PSBFTEVNRU5UX1RZUEUuRU1QVFkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldCh4ICsgaSwgeSArIGosIEVMRU1FTlRfVFlQRS5GSVJFKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50ID09PSBFTEVNRU5UX1RZUEUuQUNJRCAmJiBNYXRoLnJhbmRvbSgpIDwgMC4yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0KHgsIHksIEVMRU1FTlRfVFlQRS5FTVBUWSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBFTEVNRU5UX1RZUEUuRklSRTpcclxuICAgICAgICAgICAgICAgIGlmIChNYXRoLnJhbmRvbSgpIDwgMC4wNSkgeyBzZXQoeCwgeSwgRUxFTUVOVF9UWVBFLkhPVF9BU0gpOyB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBFTEVNRU5UX1RZUEUuSE9UX0FTSDpcclxuICAgICAgICAgICAgICAgIGlmIChNYXRoLnJhbmRvbSgpIDwgMC4wNSkgeyBzZXQoeCwgeSwgRUxFTUVOVF9UWVBFLkFTSCk7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IC0xOyBpIDw9IDE7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAtMTsgaiA8PSAxOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT09IDAgJiYgaiA9PT0gMCkgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5laWdoYm9yID0gZ3JpZFt5ICsgal0/Llt4ICsgaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZWlnaGJvciA9PT0gRUxFTUVOVF9UWVBFLldBVEVSKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXQoeCwgeSwgRUxFTUVOVF9UWVBFLkFTSCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXQoeCArIGksIHkgKyBqLCBFTEVNRU5UX1RZUEUuU01PS0UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmVpZ2hib3IgIT09IEVMRU1FTlRfVFlQRS5BU0ggJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5laWdoYm9yICE9PSBFTEVNRU5UX1RZUEUuSE9UX0FTSCAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgREVOU0lUSUVTW25laWdoYm9yXSA+IDAgJiYgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBERU5TSVRJRVNbbmVpZ2hib3JdIDwgREVOU0lUSUVTW0VMRU1FTlRfVFlQRS5MQVZBXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihNYXRoLnJhbmRvbSgpIDwgMC4wNSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldCh4ICsgaSwgeSArIGosIEVMRU1FTlRfVFlQRS5GSVJFKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXQoeCwgeSwgRUxFTUVOVF9UWVBFLkFTSCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgRUxFTUVOVF9UWVBFLlNUT05FX0FTSDpcclxuICAgICAgICAgICAgICAgIGNvbnN0IGlzU3RhYmxlID0gKERFTlNJVElFU1tncmlkW3krMV0/Llt4XV0gPj0gREVOU0lUSUVTW0VMRU1FTlRfVFlQRS5TVE9ORV9BU0hdKTtcclxuICAgICAgICAgICAgICAgIGlmIChpc1N0YWJsZSAmJiBNYXRoLnJhbmRvbSgpIDwgMC4wMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldCh4LCB5LCBFTEVNRU5UX1RZUEUuU1RPTkUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgRUxFTUVOVF9UWVBFLlBMQU5UOlxyXG4gICAgICAgICAgICAgICAgIGlmIChNYXRoLnJhbmRvbSgpIDwgMC4wNSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAtMTsgaSA8PSAxOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IC0xOyBqIDw9IDE7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzKHggKyBpLCB5ICsgaiwgRUxFTUVOVF9UWVBFLldBVEVSKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJ5IHRvIGdyb3cgaW50byBhbiBlbXB0eSBzcGFjZSBuZWFyYnlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGdyb3dYID0geCAtIGk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBncm93WSA9IHkgLSBqO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRW1wdHkoZ3Jvd1gsIGdyb3dZKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldChncm93WCwgZ3Jvd1ksIEVMRU1FTlRfVFlQRS5QTEFOVCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHVwZGF0ZWRQb3NpdGlvbnMuYWRkKHBvcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSXRlcmF0ZSB0aHJvdWdoIHRoZSBncmlkIGFuZCB1cGRhdGUgZWxlbWVudHNcclxuICAgIGZvciAobGV0IHkgPSBoZWlnaHQgLSAyOyB5ID4gMDsgeS0tKSB7XHJcbiAgICAgICAgY29uc3Qgc2NhbkRpcmVjdGlvbiA9IE1hdGgucmFuZG9tKCkgPCAwLjUgPyAxIDogLTE7XHJcbiAgICAgICAgaWYgKHNjYW5EaXJlY3Rpb24gPT09IDEpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgeCA9IDE7IHggPCB3aWR0aCAtIDE7IHgrKykge1xyXG4gICAgICAgICAgICAgICAgdXBkYXRlRWxlbWVudCh4LCB5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IHggPSB3aWR0aCAtIDI7IHggPiAwOyB4LS0pIHtcclxuICAgICAgICAgICAgICAgIHVwZGF0ZUVsZW1lbnQoeCwgeSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUHJvY2VzcyBzb2xpZHMgKG5vbi1tb3ZpbmcgYnV0IGludGVyYWN0aXZlIGVsZW1lbnRzKVxyXG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKykge1xyXG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgd2lkdGg7IHgrKykge1xyXG4gICAgICAgICAgICAgaWYgKGdyaWRbeV1beF0gPT09IEVMRU1FTlRfVFlQRS5QTEFOVCkge1xyXG4gICAgICAgICAgICAgICAgIHVwZGF0ZUVsZW1lbnQoeCwgeSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSXRlcmF0ZSB0b3AtdG8tYm90dG9tIGZvciByaXNpbmcgcGFydGljbGVzXHJcbiAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGhlaWdodDsgeSsrKSB7XHJcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB3aWR0aDsgeCsrKSB7XHJcbiAgICAgICAgICAgICBpZiAoZ3JpZFt5XVt4XSA9PT0gRUxFTUVOVF9UWVBFLlNNT0tFIHx8IGdyaWRbeV1beF0gPT09IEVMRU1FTlRfVFlQRS5GSVJFKSB7XHJcbiAgICAgICAgICAgICAgICAgdXBkYXRlRWxlbWVudCh4LCB5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufTsgIl0sIm5hbWVzIjpbIkVMRU1FTlRfVFlQRSIsIkVNUFRZIiwiV0FMTCIsIlNBTkQiLCJXQVRFUiIsIlBMQU5UIiwiRklSRSIsIkxBVkEiLCJBQ0lEIiwiU01PS0UiLCJTVE9ORSIsIlNUT05FX0FTSCIsIkFTSCIsIkhPVF9BU0giLCJFTEVNRU5UX0NPTE9SUyIsIkRFTlNJVElFUyIsIkluZmluaXR5IiwiTE9DQUxfU1RPUkFHRV9LRVkiLCJDRUxMX1NJWkUiLCJ3aWR0aCIsImhlaWdodCIsImdyaWQiLCJhcmVXYWxsc09uIiwic2V0V2FsbHMiLCJlbmFibGVkIiwid2FsbFR5cGUiLCJ5IiwieCIsInNhdmVXb3JsZCIsImxvY2FsU3RvcmFnZSIsInNldEl0ZW0iLCJKU09OIiwic3RyaW5naWZ5IiwiY2xlYXIiLCJyZW1vdmVJdGVtIiwiaW5pdCIsImNhbnZhc1dpZHRoIiwiY2FudmFzSGVpZ2h0IiwiTWF0aCIsImZsb29yIiwic2F2ZWRHcmlkIiwiZ2V0SXRlbSIsInBhcnNlZEdyaWQiLCJwYXJzZSIsImxlbmd0aCIsImUiLCJjb25zb2xlIiwiZXJyb3IiLCJBcnJheSIsImZpbGwiLCJtYXAiLCJnZXRHcmlkIiwiZ2V0Q2VsbFNpemUiLCJzZXRFbGVtZW50IiwiZWxlbWVudFR5cGUiLCJicnVzaFNpemUiLCJyYWRpdXMiLCJpIiwiaiIsIm5ld1giLCJuZXdZIiwibW92ZSIsIngxIiwieTEiLCJ4MiIsInkyIiwidGVtcCIsImlzV2l0aGluQm91bmRzIiwiaXNFbXB0eSIsImlzIiwic2V0IiwidXBkYXRlIiwidXBkYXRlZFBvc2l0aW9ucyIsIlNldCIsInVwZGF0ZUVsZW1lbnQiLCJwb3MiLCJoYXMiLCJlbGVtZW50IiwiZGlyIiwicmFuZG9tIiwiYWRkIiwiZGVuc2l0eSIsImJlbG93IiwidW5kZWZpbmVkIiwiZGlhZzEiLCJkaWFnMiIsImlzU2xvdyIsIm5laWdoYm9yIiwiaXNTdGFibGUiLCJncm93WCIsImdyb3dZIiwic2NhbkRpcmVjdGlvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/simulation/world.ts\n"));

/***/ })

});