"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/app/simulation/world.ts":
/*!*************************************!*\
  !*** ./src/app/simulation/world.ts ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DENSITIES: function() { return /* binding */ DENSITIES; },\n/* harmony export */   ELEMENT_COLORS: function() { return /* binding */ ELEMENT_COLORS; },\n/* harmony export */   ELEMENT_TYPE: function() { return /* binding */ ELEMENT_TYPE; },\n/* harmony export */   clear: function() { return /* binding */ clear; },\n/* harmony export */   getCellSize: function() { return /* binding */ getCellSize; },\n/* harmony export */   getGrid: function() { return /* binding */ getGrid; },\n/* harmony export */   init: function() { return /* binding */ init; },\n/* harmony export */   saveWorld: function() { return /* binding */ saveWorld; },\n/* harmony export */   setElement: function() { return /* binding */ setElement; },\n/* harmony export */   setWalls: function() { return /* binding */ setWalls; },\n/* harmony export */   update: function() { return /* binding */ update; }\n/* harmony export */ });\nconst ELEMENT_TYPE = {\n    EMPTY: 0,\n    WALL: 1,\n    SAND: 2,\n    WATER: 3,\n    PLANT: 4,\n    FIRE: 5,\n    LAVA: 6,\n    ACID: 7,\n    SMOKE: 8,\n    STONE: 9,\n    STONE_ASH: 10,\n    ASH: 11,\n    HOT_ASH: 12\n};\nconst ELEMENT_COLORS = {\n    [ELEMENT_TYPE.EMPTY]: \"#000000\",\n    [ELEMENT_TYPE.WALL]: \"#505050\",\n    [ELEMENT_TYPE.SAND]: \"#f0d9a5\",\n    [ELEMENT_TYPE.WATER]: \"#3498db\",\n    [ELEMENT_TYPE.PLANT]: \"#2ecc71\",\n    [ELEMENT_TYPE.FIRE]: \"#e74c3c\",\n    [ELEMENT_TYPE.LAVA]: \"#d35400\",\n    [ELEMENT_TYPE.ACID]: \"#9b59b6\",\n    [ELEMENT_TYPE.SMOKE]: \"#888888\",\n    [ELEMENT_TYPE.STONE]: \"#808080\",\n    [ELEMENT_TYPE.STONE_ASH]: \"#6b6b6b\",\n    [ELEMENT_TYPE.ASH]: \"#2b2b2b\",\n    [ELEMENT_TYPE.HOT_ASH]: \"#db4f27\"\n};\nconst DENSITIES = {\n    [ELEMENT_TYPE.EMPTY]: 0,\n    [ELEMENT_TYPE.SMOKE]: 1,\n    [ELEMENT_TYPE.FIRE]: 1,\n    [ELEMENT_TYPE.WATER]: 10,\n    [ELEMENT_TYPE.ACID]: 11,\n    [ELEMENT_TYPE.ASH]: 12,\n    [ELEMENT_TYPE.HOT_ASH]: 12,\n    [ELEMENT_TYPE.SAND]: 15,\n    [ELEMENT_TYPE.PLANT]: 20,\n    [ELEMENT_TYPE.STONE_ASH]: 22,\n    [ELEMENT_TYPE.LAVA]: 25,\n    [ELEMENT_TYPE.STONE]: 30,\n    [ELEMENT_TYPE.WALL]: Infinity\n};\nconst LOCAL_STORAGE_KEY = \"sandSimulationGrid\";\nconst CELL_SIZE = 5;\nlet width, height;\nlet grid;\nlet areWallsOn = true;\nconst setWalls = (enabled)=>{\n    areWallsOn = enabled;\n    const wallType = enabled ? ELEMENT_TYPE.WALL : ELEMENT_TYPE.EMPTY;\n    if (!grid) return;\n    for(let y = 0; y < height; y++){\n        if (grid[y]) {\n            grid[y][0] = wallType;\n            grid[y][width - 1] = wallType;\n        }\n    }\n    for(let x = 0; x < width; x++){\n        if (grid[0]) grid[0][x] = wallType;\n        if (grid[height - 1]) grid[height - 1][x] = wallType;\n    }\n};\nconst saveWorld = ()=>{\n    if (grid) {\n        localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(grid));\n    }\n};\nconst clear = ()=>{\n    for(let y = 0; y < height; y++){\n        for(let x = 0; x < width; x++){\n            grid[y][x] = ELEMENT_TYPE.EMPTY;\n        }\n    }\n    if (areWallsOn) {\n        setWalls(true);\n    }\n    localStorage.removeItem(LOCAL_STORAGE_KEY);\n};\nconst init = (canvasWidth, canvasHeight)=>{\n    width = Math.floor(canvasWidth / CELL_SIZE);\n    height = Math.floor(canvasHeight / CELL_SIZE);\n    const savedGrid = localStorage.getItem(LOCAL_STORAGE_KEY);\n    if (savedGrid) {\n        try {\n            const parsedGrid = JSON.parse(savedGrid);\n            if (parsedGrid && parsedGrid.length === height && parsedGrid[0].length === width) {\n                grid = parsedGrid;\n                return;\n            }\n        } catch (e) {\n            console.error(\"Failed to parse saved grid:\", e);\n        }\n    }\n    grid = Array(height).fill(0).map(()=>Array(width).fill(ELEMENT_TYPE.EMPTY));\n    setWalls(areWallsOn);\n};\nconst getGrid = ()=>grid;\nconst getCellSize = ()=>CELL_SIZE;\nconst setElement = (x, y, elementType, brushSize)=>{\n    const radius = Math.floor(brushSize / CELL_SIZE / 2);\n    for(let i = -radius; i <= radius; i++){\n        for(let j = -radius; j <= radius; j++){\n            if (i * i + j * j <= radius * radius) {\n                const newX = x + i;\n                const newY = y + j;\n                if (newX >= 0 && newX < width && newY >= 0 && newY < height) {\n                    if (grid[newY][newX] === ELEMENT_TYPE.EMPTY || elementType === ELEMENT_TYPE.EMPTY) {\n                        grid[newY][newX] = elementType;\n                    }\n                }\n            }\n        }\n    }\n};\nconst move = (x1, y1, x2, y2)=>{\n    const temp = grid[y1][x1];\n    grid[y1][x1] = grid[y2][x2];\n    grid[y2][x2] = temp;\n};\nconst isWithinBounds = (x, y)=>{\n    return y >= 0 && y < height && x >= 0 && x < width;\n};\nconst isEmpty = (x, y)=>{\n    return isWithinBounds(x, y) && grid[y][x] === ELEMENT_TYPE.EMPTY;\n};\nconst is = (x, y, elementType)=>{\n    return isWithinBounds(x, y) && grid[y][x] === elementType;\n};\nconst set = (x, y, elementType)=>{\n    if (isWithinBounds(x, y)) {\n        grid[y][x] = elementType;\n    }\n};\nconst update = ()=>{\n    const updatedPositions = new Set();\n    const updateElement = (x, y)=>{\n        const pos = \"\".concat(x, \",\").concat(y);\n        if (updatedPositions.has(pos)) {\n            return; // Already updated in this frame\n        }\n        const element = grid[y][x];\n        // --- Out of Bounds Check ---\n        if (!areWallsOn) {\n            if (y <= 0 && (element === ELEMENT_TYPE.FIRE || element === ELEMENT_TYPE.SMOKE) || y >= height - 1 && DENSITIES[element] > DENSITIES[ELEMENT_TYPE.EMPTY] || (x <= 0 || x >= width - 1) && DENSITIES[element] > DENSITIES[ELEMENT_TYPE.EMPTY]) {\n                set(x, y, ELEMENT_TYPE.EMPTY);\n                return;\n            }\n        }\n        // --- Movement Phase ---\n        // A particle will attempt to move, and if it does, its turn ends.\n        // Interactions only happen if a particle cannot move.\n        // Gas Movement (Up)\n        if (element === ELEMENT_TYPE.FIRE || element === ELEMENT_TYPE.SMOKE) {\n            // Gases are less likely to move, making them dissipate more naturally\n            if (Math.random() > 0.4) {\n                const dir = Math.random() < 0.5 ? -1 : 1;\n                // Up\n                if (isEmpty(x, y - 1)) {\n                    move(x, y, x, y - 1);\n                    updatedPositions.add(\"\".concat(x, \",\").concat(y - 1));\n                    return;\n                }\n                // Diagonal Up\n                if (isEmpty(x + dir, y - 1)) {\n                    move(x, y, x + dir, y - 1);\n                    updatedPositions.add(\"\".concat(x + dir, \",\").concat(y - 1));\n                    return;\n                }\n                // Sideways\n                if (isEmpty(x + dir, y)) {\n                    move(x, y, x + dir, y);\n                    updatedPositions.add(\"\".concat(x + dir, \",\").concat(y));\n                    return;\n                }\n            }\n        } else if (DENSITIES[element] > DENSITIES[ELEMENT_TYPE.EMPTY] && DENSITIES[element] < DENSITIES[ELEMENT_TYPE.WALL]) {\n            var _grid_, _grid_1, _grid_2;\n            const density = DENSITIES[element];\n            // Down\n            const below = (_grid_ = grid[y + 1]) === null || _grid_ === void 0 ? void 0 : _grid_[x];\n            if (below !== undefined && density > DENSITIES[below]) {\n                move(x, y, x, y + 1);\n                updatedPositions.add(\"\".concat(x, \",\").concat(y + 1));\n                return;\n            }\n            // Diagonal Down\n            const dir = Math.random() < 0.5 ? -1 : 1;\n            const diag1 = (_grid_1 = grid[y + 1]) === null || _grid_1 === void 0 ? void 0 : _grid_1[x + dir];\n            if (diag1 !== undefined && density > DENSITIES[diag1]) {\n                move(x, y, x + dir, y + 1);\n                updatedPositions.add(\"\".concat(x + dir, \",\").concat(y + 1));\n                return;\n            }\n            const diag2 = (_grid_2 = grid[y + 1]) === null || _grid_2 === void 0 ? void 0 : _grid_2[x - dir];\n            if (diag2 !== undefined && density > DENSITIES[diag2]) {\n                move(x, y, x - dir, y + 1);\n                updatedPositions.add(\"\".concat(x - dir, \",\").concat(y + 1));\n                return;\n            }\n            // Sideways (Liquids Only)\n            if (element === ELEMENT_TYPE.WATER || element === ELEMENT_TYPE.ACID || element === ELEMENT_TYPE.LAVA) {\n                const isSlow = element === ELEMENT_TYPE.LAVA && Math.random() < 0.5;\n                if (!isSlow) {\n                    if (isEmpty(x + dir, y)) {\n                        move(x, y, x + dir, y);\n                        updatedPositions.add(\"\".concat(x + dir, \",\").concat(y));\n                        return;\n                    }\n                    if (isEmpty(x - dir, y)) {\n                        move(x, y, x - dir, y);\n                        updatedPositions.add(\"\".concat(x - dir, \",\").concat(y));\n                        return;\n                    }\n                }\n            }\n        }\n        // --- Interaction Phase ---\n        // This code only runs if the particle did not move in the movement phase.\n        switch(element){\n            case ELEMENT_TYPE.LAVA:\n            case ELEMENT_TYPE.ACID:\n                for(let i = -1; i <= 1; i++){\n                    for(let j = -1; j <= 1; j++){\n                        var _grid_3;\n                        if (i === 0 && j === 0) continue;\n                        const neighbor = (_grid_3 = grid[y + j]) === null || _grid_3 === void 0 ? void 0 : _grid_3[x + i];\n                        if (neighbor === undefined || neighbor === ELEMENT_TYPE.WALL || neighbor === element) continue;\n                        if (is(x + i, y + j, ELEMENT_TYPE.LAVA) && element === ELEMENT_TYPE.ACID) {\n                            set(x + i, y + j, ELEMENT_TYPE.SMOKE);\n                            set(x, y, ELEMENT_TYPE.SMOKE);\n                        } else if (neighbor !== ELEMENT_TYPE.EMPTY) {\n                            set(x + i, y + j, ELEMENT_TYPE.FIRE);\n                            if (element === ELEMENT_TYPE.ACID && Math.random() < 0.2) {\n                                set(x, y, ELEMENT_TYPE.EMPTY);\n                            }\n                        }\n                    }\n                }\n                break;\n            case ELEMENT_TYPE.FIRE:\n                if (Math.random() < 0.05) {\n                    set(x, y, ELEMENT_TYPE.HOT_ASH);\n                }\n                break;\n            case ELEMENT_TYPE.HOT_ASH:\n                if (Math.random() < 0.05) {\n                    set(x, y, ELEMENT_TYPE.ASH);\n                    break;\n                }\n                for(let i = -1; i <= 1; i++){\n                    for(let j = -1; j <= 1; j++){\n                        var _grid_4;\n                        if (i === 0 && j === 0) continue;\n                        const neighbor = (_grid_4 = grid[y + j]) === null || _grid_4 === void 0 ? void 0 : _grid_4[x + i];\n                        if (neighbor === undefined) continue;\n                        if (neighbor === ELEMENT_TYPE.WATER) {\n                            set(x, y, ELEMENT_TYPE.ASH);\n                            set(x + i, y + j, ELEMENT_TYPE.SMOKE);\n                        } else if (neighbor !== ELEMENT_TYPE.ASH && neighbor !== ELEMENT_TYPE.HOT_ASH && DENSITIES[neighbor] > 0 && DENSITIES[neighbor] < DENSITIES[ELEMENT_TYPE.LAVA]) {\n                            if (Math.random() < 0.05) {\n                                set(x + i, y + j, ELEMENT_TYPE.FIRE);\n                                set(x, y, ELEMENT_TYPE.ASH);\n                            }\n                        } else if (neighbor === ELEMENT_TYPE.ASH || neighbor === ELEMENT_TYPE.HOT_ASH) {\n                            if (Math.random() < 0.001) {\n                                set(x + i, y + j, ELEMENT_TYPE.FIRE);\n                                set(x, y, ELEMENT_TYPE.ASH);\n                            }\n                        }\n                    }\n                }\n                break;\n            case ELEMENT_TYPE.STONE_ASH:\n                var _grid_5;\n                const isStable = DENSITIES[(_grid_5 = grid[y + 1]) === null || _grid_5 === void 0 ? void 0 : _grid_5[x]] >= DENSITIES[ELEMENT_TYPE.STONE_ASH];\n                if (isStable && Math.random() < 0.01) {\n                    set(x, y, ELEMENT_TYPE.STONE);\n                }\n                break;\n            case ELEMENT_TYPE.PLANT:\n                if (Math.random() < 0.05) {\n                    for(let i = -1; i <= 1; i++){\n                        for(let j = -1; j <= 1; j++){\n                            if (is(x + i, y + j, ELEMENT_TYPE.WATER)) {\n                                // Try to grow into an empty space nearby\n                                const growX = x - i;\n                                const growY = y - j;\n                                if (isEmpty(growX, growY)) {\n                                    set(growX, growY, ELEMENT_TYPE.PLANT);\n                                }\n                            }\n                        }\n                    }\n                }\n                break;\n            case ELEMENT_TYPE.SMOKE:\n                // If smoke is stuck, it has a chance to disappear.\n                if (Math.random() < 0.01) {\n                    set(x, y, ELEMENT_TYPE.EMPTY);\n                }\n                break;\n        }\n        updatedPositions.add(pos);\n    };\n    // Iterate through the grid and update elements\n    for(let y = height - 1; y >= 0; y--){\n        const scanDirection = Math.random() < 0.5 ? 1 : -1;\n        if (scanDirection === 1) {\n            for(let x = 0; x < width; x++){\n                updateElement(x, y);\n            }\n        } else {\n            for(let x = width - 1; x >= 0; x--){\n                updateElement(x, y);\n            }\n        }\n    }\n    // Process solids (non-moving but interactive elements)\n    for(let y = 0; y < height; y++){\n        for(let x = 0; x < width; x++){\n            if (grid[y][x] === ELEMENT_TYPE.PLANT) {\n                updateElement(x, y);\n            }\n        }\n    }\n    // Iterate top-to-bottom for rising particles\n    for(let y = 0; y < height; y++){\n        for(let x = 0; x < width; x++){\n            if (grid[y][x] === ELEMENT_TYPE.SMOKE || grid[y][x] === ELEMENT_TYPE.FIRE) {\n                updateElement(x, y);\n            }\n        }\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvc2ltdWxhdGlvbi93b3JsZC50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFPLE1BQU1BLGVBQWU7SUFDMUJDLE9BQU87SUFDUEMsTUFBTTtJQUNOQyxNQUFNO0lBQ05DLE9BQU87SUFDUEMsT0FBTztJQUNQQyxNQUFNO0lBQ05DLE1BQU07SUFDTkMsTUFBTTtJQUNOQyxPQUFPO0lBQ1BDLE9BQU87SUFDUEMsV0FBVztJQUNYQyxLQUFLO0lBQ0xDLFNBQVM7QUFDWCxFQUFXO0FBSUosTUFBTUMsaUJBQThDO0lBQ3ZELENBQUNkLGFBQWFDLEtBQUssQ0FBQyxFQUFFO0lBQ3RCLENBQUNELGFBQWFFLElBQUksQ0FBQyxFQUFFO0lBQ3JCLENBQUNGLGFBQWFHLElBQUksQ0FBQyxFQUFFO0lBQ3JCLENBQUNILGFBQWFJLEtBQUssQ0FBQyxFQUFFO0lBQ3RCLENBQUNKLGFBQWFLLEtBQUssQ0FBQyxFQUFFO0lBQ3RCLENBQUNMLGFBQWFNLElBQUksQ0FBQyxFQUFFO0lBQ3JCLENBQUNOLGFBQWFPLElBQUksQ0FBQyxFQUFFO0lBQ3JCLENBQUNQLGFBQWFRLElBQUksQ0FBQyxFQUFFO0lBQ3JCLENBQUNSLGFBQWFTLEtBQUssQ0FBQyxFQUFFO0lBQ3RCLENBQUNULGFBQWFVLEtBQUssQ0FBQyxFQUFFO0lBQ3RCLENBQUNWLGFBQWFXLFNBQVMsQ0FBQyxFQUFFO0lBQzFCLENBQUNYLGFBQWFZLEdBQUcsQ0FBQyxFQUFFO0lBQ3BCLENBQUNaLGFBQWFhLE9BQU8sQ0FBQyxFQUFFO0FBQzVCLEVBQUU7QUFFSyxNQUFNRSxZQUF5QztJQUNsRCxDQUFDZixhQUFhQyxLQUFLLENBQUMsRUFBRTtJQUN0QixDQUFDRCxhQUFhUyxLQUFLLENBQUMsRUFBRTtJQUN0QixDQUFDVCxhQUFhTSxJQUFJLENBQUMsRUFBRTtJQUNyQixDQUFDTixhQUFhSSxLQUFLLENBQUMsRUFBRTtJQUN0QixDQUFDSixhQUFhUSxJQUFJLENB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QSxJQUFJTixRQUFRTSxJQUFLO1FBQzdCLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJUixPQUFPUSxJQUFLO1lBQzNCLElBQUlOLElBQUksQ0FBQ0ssRUFBRSxDQUFDQyxFQUFFLEtBQUszQixhQUFhUyxLQUFLLElBQUlZLElBQUksQ0FBQ0ssRUFBRSxDQUFDQyxFQUFFLEtBQUszQixhQUFhTSxJQUFJLEVBQUU7Z0JBQ3ZFb0UsY0FBYy9DLEdBQUdEO1lBQ3RCO1FBQ0o7SUFDSjtBQUNKLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2FwcC9zaW11bGF0aW9uL3dvcmxkLnRzPzY1NTYiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IEVMRU1FTlRfVFlQRSA9IHtcclxuICBFTVBUWTogMCxcclxuICBXQUxMOiAxLFxyXG4gIFNBTkQ6IDIsXHJcbiAgV0FURVI6IDMsXHJcbiAgUExBTlQ6IDQsXHJcbiAgRklSRTogNSxcclxuICBMQVZBOiA2LFxyXG4gIEFDSUQ6IDcsXHJcbiAgU01PS0U6IDgsXHJcbiAgU1RPTkU6IDksXHJcbiAgU1RPTkVfQVNIOiAxMCxcclxuICBBU0g6IDExLFxyXG4gIEhPVF9BU0g6IDEyLFxyXG59IGFzIGNvbnN0O1xyXG5cclxuZXhwb3J0IHR5cGUgRWxlbWVudFR5cGUgPSB0eXBlb2YgRUxFTUVOVF9UWVBFW2tleW9mIHR5cGVvZiBFTEVNRU5UX1RZUEVdO1xyXG5cclxuZXhwb3J0IGNvbnN0IEVMRU1FTlRfQ09MT1JTOiBSZWNvcmQ8RWxlbWVudFR5cGUsIHN0cmluZz4gPSB7XHJcbiAgICBbRUxFTUVOVF9UWVBFLkVNUFRZXTogJyMwMDAwMDAnLFxyXG4gICAgW0VMRU1FTlRfVFlQRS5XQUxMXTogJyM1MDUwNTAnLFxyXG4gICAgW0VMRU1FTlRfVFlQRS5TQU5EXTogJyNmMGQ5YTUnLFxyXG4gICAgW0VMRU1FTlRfVFlQRS5XQVRFUl06ICcjMzQ5OGRiJyxcclxuICAgIFtFTEVNRU5UX1RZUEUuUExBTlRdOiAnIzJlY2M3MScsXHJcbiAgICBbRUxFTUVOVF9UWVBFLkZJUkVdOiAnI2U3NGMzYycsXHJcbiAgICBbRUxFTUVOVF9UWVBFLkxBVkFdOiAnI2QzNTQwMCcsXHJcbiAgICBbRUxFTUVOVF9UWVBFLkFDSURdOiAnIzliNTliNicsXHJcbiAgICBbRUxFTUVOVF9UWVBFLlNNT0tFXTogJyM4ODg4ODgnLFxyXG4gICAgW0VMRU1FTlRfVFlQRS5TVE9ORV06ICcjODA4MDgwJyxcclxuICAgIFtFTEVNRU5UX1RZUEUuU1RPTkVfQVNIXTogJyM2YjZiNmInLFxyXG4gICAgW0VMRU1FTlRfVFlQRS5BU0hdOiAnIzJiMmIyYicsXHJcbiAgICBbRUxFTUVOVF9UWVBFLkhPVF9BU0hdOiAnI2RiNGYyNycsXHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgREVOU0lUSUVTOiBSZWNvcmQ8RWxlbWVudFR5cGUsIG51bWJlcj4gPSB7XHJcbiAgICBbRUxFTUVOVF9UWVBFLkVNUFRZXTogMCxcclxuICAgIFtFTEVNRU5UX1RZUEUuU01PS0VdOiAxLFxyXG4gICAgW0VMRU1FTlRfVFlQRS5GSVJFXTogMSxcclxuICAgIFtFTEVNRU5UX1RZUEUuV0FURVJdOiAxMCxcclxuICAgIFtFTEVNRU5UX1RZUEUuQUNJRF06IDExLFxyXG4gICAgW0VMRU1FTlRfVFlQRS5BU0hdOiAxMixcclxuICAgIFtFTEVNRU5UX1RZUEUuSE9UX0FTSF06IDEyLFxyXG4gICAgW0VMRU1FTlRfVFlQRS5TQU5EXTogMTUsXHJcbiAgICBbRUxFTUVOVF9UWVBFLlBMQU5UXTogMjAsXHJcbiAgICBbRUxFTUVOVF9UWVBFLlNUT05FX0FTSF06IDIyLFxyXG4gICAgW0VMRU1FTlRfVFlQRS5MQVZBXTogMjUsXHJcbiAgICBbRUxFTUVOVF9UWVBFLlNUT05FXTogMzAsXHJcbiAgICBbRUxFTUVOVF9UWVBFLldBTExdOiBJbmZpbml0eSxcclxufTtcclxuXHJcbmNvbnN0IExPQ0FMX1NUT1JBR0VfS0VZID0gJ3NhbmRTaW11bGF0aW9uR3JpZCc7XHJcbmNvbnN0IENFTExfU0laRSA9IDU7XHJcbmxldCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcjtcclxubGV0IGdyaWQ6IEVsZW1lbnRUeXBlW11bXTtcclxubGV0IGFyZVdhbGxzT24gPSB0cnVlO1xyXG5cclxuZXhwb3J0IGNvbnN0IHNldFdhbGxzID0gKGVuYWJsZWQ6IGJvb2xlYW4pID0+IHtcclxuICAgIGFyZVdhbGxzT24gPSBlbmFibGVkO1xyXG4gICAgY29uc3Qgd2FsbFR5cGUgPSBlbmFibGVkID8gRUxFTUVOVF9UWVBFLldBTEwgOiBFTEVNRU5UX1RZUEUuRU1QVFk7XHJcblxyXG4gICAgaWYgKCFncmlkKSByZXR1cm47XHJcblxyXG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKykge1xyXG4gICAgICAgIGlmIChncmlkW3ldKSB7XHJcbiAgICAgICAgICAgIGdyaWRbeV1bMF0gPSB3YWxsVHlwZTtcclxuICAgICAgICAgICAgZ3JpZFt5XVt3aWR0aCAtIDFdID0gd2FsbFR5cGU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZm9yIChsZXQgeCA9IDA7IHggPCB3aWR0aDsgeCsrKSB7XHJcbiAgICAgICAgaWYgKGdyaWRbMF0pIGdyaWRbMF1beF0gPSB3YWxsVHlwZTtcclxuICAgICAgICBpZiAoZ3JpZFtoZWlnaHQgLSAxXSkgZ3JpZFtoZWlnaHQgLSAxXVt4XSA9IHdhbGxUeXBlO1xyXG4gICAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHNhdmVXb3JsZCA9ICgpID0+IHtcclxuICAgIGlmIChncmlkKSB7XHJcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oTE9DQUxfU1RPUkFHRV9LRVksIEpTT04uc3RyaW5naWZ5KGdyaWQpKTtcclxuICAgIH1cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBjbGVhciA9ICgpID0+IHtcclxuICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHtcclxuICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHdpZHRoOyB4KyspIHtcclxuICAgICAgICAgICAgZ3JpZFt5XVt4XSA9IEVMRU1FTlRfVFlQRS5FTVBUWTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoYXJlV2FsbHNPbikge1xyXG4gICAgICAgIHNldFdhbGxzKHRydWUpO1xyXG4gICAgfVxyXG4gICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oTE9DQUxfU1RPUkFHRV9LRVkpO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGluaXQgPSAoY2FudmFzV2lkdGg6IG51bWJlciwgY2FudmFzSGVpZ2h0OiBudW1iZXIpID0+IHtcclxuICAgIHdpZHRoID0gTWF0aC5mbG9vcihjYW52YXNXaWR0aCAvIENFTExfU0laRSk7XHJcbiAgICBoZWlnaHQgPSBNYXRoLmZsb29yKGNhbnZhc0hlaWdodCAvIENFTExfU0laRSk7XHJcblxyXG4gICAgY29uc3Qgc2F2ZWRHcmlkID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oTE9DQUxfU1RPUkFHRV9LRVkpO1xyXG4gICAgXHJcbiAgICBpZiAoc2F2ZWRHcmlkKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3QgcGFyc2VkR3JpZCA9IEpTT04ucGFyc2Uoc2F2ZWRHcmlkKTtcclxuICAgICAgICAgICAgaWYgKHBhcnNlZEdyaWQgJiYgcGFyc2VkR3JpZC5sZW5ndGggPT09IGhlaWdodCAmJiBwYXJzZWRHcmlkWzBdLmxlbmd0aCA9PT0gd2lkdGgpIHtcclxuICAgICAgICAgICAgICAgIGdyaWQgPSBwYXJzZWRHcmlkO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIHBhcnNlIHNhdmVkIGdyaWQ6XCIsIGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBncmlkID0gQXJyYXkoaGVpZ2h0KS5maWxsKDApLm1hcCgoKSA9PiBBcnJheSh3aWR0aCkuZmlsbChFTEVNRU5UX1RZUEUuRU1QVFkpKTtcclxuICAgIHNldFdhbGxzKGFyZVdhbGxzT24pO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGdldEdyaWQgPSAoKSA9PiBncmlkO1xyXG5leHBvcnQgY29uc3QgZ2V0Q2VsbFNpemUgPSAoKSA9PiBDRUxMX1NJWkU7XHJcblxyXG5leHBvcnQgY29uc3Qgc2V0RWxlbWVudCA9ICh4OiBudW1iZXIsIHk6IG51bWJlciwgZWxlbWVudFR5cGU6IEVsZW1lbnRUeXBlLCBicnVzaFNpemU6IG51bWJlcikgPT4ge1xyXG4gICAgY29uc3QgcmFkaXVzID0gTWF0aC5mbG9vcihicnVzaFNpemUgLyBDRUxMX1NJWkUgLyAyKTtcclxuICAgIGZvciAobGV0IGkgPSAtcmFkaXVzOyBpIDw9IHJhZGl1czsgaSsrKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaiA9IC1yYWRpdXM7IGogPD0gcmFkaXVzOyBqKyspIHtcclxuICAgICAgICAgICAgaWYgKGkqaSArIGoqaiA8PSByYWRpdXMqcmFkaXVzKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdYID0geCArIGk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdZID0geSArIGo7XHJcbiAgICAgICAgICAgICAgICBpZiAobmV3WCA+PSAwICYmIG5ld1ggPCB3aWR0aCAmJiBuZXdZID49IDAgJiYgbmV3WSA8IGhlaWdodCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChncmlkW25ld1ldW25ld1hdID09PSBFTEVNRU5UX1RZUEUuRU1QVFkgfHwgZWxlbWVudFR5cGUgPT09IEVMRU1FTlRfVFlQRS5FTVBUWSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBncmlkW25ld1ldW25ld1hdID0gZWxlbWVudFR5cGU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxuY29uc3QgbW92ZSA9ICh4MTogbnVtYmVyLCB5MTogbnVtYmVyLCB4MjogbnVtYmVyLCB5MjogbnVtYmVyKSA9PiB7XHJcbiAgICBjb25zdCB0ZW1wID0gZ3JpZFt5MV1beDFdO1xyXG4gICAgZ3JpZFt5MV1beDFdID0gZ3JpZFt5Ml1beDJdO1xyXG4gICAgZ3JpZFt5Ml1beDJdID0gdGVtcDtcclxufVxyXG5cclxuY29uc3QgaXNXaXRoaW5Cb3VuZHMgPSAoeDogbnVtYmVyLCB5OiBudW1iZXIpID0+IHtcclxuICAgIHJldHVybiB5ID49IDAgJiYgeSA8IGhlaWdodCAmJiB4ID49IDAgJiYgeCA8IHdpZHRoO1xyXG59XHJcblxyXG5jb25zdCBpc0VtcHR5ID0gKHg6IG51bWJlciwgeTogbnVtYmVyKSA9PiB7XHJcbiAgICByZXR1cm4gaXNXaXRoaW5Cb3VuZHMoeCwgeSkgJiYgZ3JpZFt5XVt4XSA9PT0gRUxFTUVOVF9UWVBFLkVNUFRZO1xyXG59XHJcblxyXG5jb25zdCBpcyA9ICh4OiBudW1iZXIsIHk6IG51bWJlciwgZWxlbWVudFR5cGU6IEVsZW1lbnRUeXBlKSA9PiB7XHJcbiAgICByZXR1cm4gaXNXaXRoaW5Cb3VuZHMoeCwgeSkgJiYgZ3JpZFt5XVt4XSA9PT0gZWxlbWVudFR5cGU7XHJcbn1cclxuXHJcbmNvbnN0IHNldCA9ICh4OiBudW1iZXIsIHk6IG51bWJlciwgZWxlbWVudFR5cGU6IEVsZW1lbnRUeXBlKSA9PiB7XHJcbiAgICBpZiAoaXNXaXRoaW5Cb3VuZHMoeCwgeSkpIHtcclxuICAgICAgICBncmlkW3ldW3hdID0gZWxlbWVudFR5cGU7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCB1cGRhdGUgPSAoKSA9PiB7XHJcbiAgICBjb25zdCB1cGRhdGVkUG9zaXRpb25zID0gbmV3IFNldDxzdHJpbmc+KCk7XHJcblxyXG4gICAgY29uc3QgdXBkYXRlRWxlbWVudCA9ICh4OiBudW1iZXIsIHk6IG51bWJlcikgPT4ge1xyXG4gICAgICAgIGNvbnN0IHBvcyA9IGAke3h9LCR7eX1gO1xyXG4gICAgICAgIGlmICh1cGRhdGVkUG9zaXRpb25zLmhhcyhwb3MpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjsgLy8gQWxyZWFkeSB1cGRhdGVkIGluIHRoaXMgZnJhbWVcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBncmlkW3ldW3hdO1xyXG5cclxuICAgICAgICAvLyAtLS0gT3V0IG9mIEJvdW5kcyBDaGVjayAtLS1cclxuICAgICAgICBpZiAoIWFyZVdhbGxzT24pIHtcclxuICAgICAgICAgICAgaWYgKCh5IDw9IDAgJiYgKGVsZW1lbnQgPT09IEVMRU1FTlRfVFlQRS5GSVJFIHx8IGVsZW1lbnQgPT09IEVMRU1FTlRfVFlQRS5TTU9LRSkpIHx8XHJcbiAgICAgICAgICAgICAgICAoeSA+PSBoZWlnaHQgLSAxICYmIERFTlNJVElFU1tlbGVtZW50XSA+IERFTlNJVElFU1tFTEVNRU5UX1RZUEUuRU1QVFldKSB8fFxyXG4gICAgICAgICAgICAgICAgKCh4IDw9IDAgfHwgeCA+PSB3aWR0aCAtIDEpICYmIERFTlNJVElFU1tlbGVtZW50XSA+IERFTlNJVElFU1tFTEVNRU5UX1RZUEUuRU1QVFldKVxyXG4gICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgIHNldCh4LCB5LCBFTEVNRU5UX1RZUEUuRU1QVFkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyAtLS0gTW92ZW1lbnQgUGhhc2UgLS0tXHJcbiAgICAgICAgLy8gQSBwYXJ0aWNsZSB3aWxsIGF0dGVtcHQgdG8gbW92ZSwgYW5kIGlmIGl0IGRvZXMsIGl0cyB0dXJuIGVuZHMuXHJcbiAgICAgICAgLy8gSW50ZXJhY3Rpb25zIG9ubHkgaGFwcGVuIGlmIGEgcGFydGljbGUgY2Fubm90IG1vdmUuXHJcblxyXG4gICAgICAgIC8vIEdhcyBNb3ZlbWVudCAoVXApXHJcbiAgICAgICAgaWYgKGVsZW1lbnQgPT09IEVMRU1FTlRfVFlQRS5GSVJFIHx8IGVsZW1lbnQgPT09IEVMRU1FTlRfVFlQRS5TTU9LRSkge1xyXG4gICAgICAgICAgICAvLyBHYXNlcyBhcmUgbGVzcyBsaWtlbHkgdG8gbW92ZSwgbWFraW5nIHRoZW0gZGlzc2lwYXRlIG1vcmUgbmF0dXJhbGx5XHJcbiAgICAgICAgICAgIGlmIChNYXRoLnJhbmRvbSgpID4gMC40KSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBkaXIgPSBNYXRoLnJhbmRvbSgpIDwgMC41ID8gLTEgOiAxO1xyXG4gICAgICAgICAgICAgICAgLy8gVXBcclxuICAgICAgICAgICAgICAgIGlmIChpc0VtcHR5KHgsIHkgLSAxKSkgeyBtb3ZlKHgsIHksIHgsIHkgLSAxKTsgdXBkYXRlZFBvc2l0aW9ucy5hZGQoYCR7eH0sJHt5LTF9YCk7IHJldHVybjsgfVxyXG4gICAgICAgICAgICAgICAgLy8gRGlhZ29uYWwgVXBcclxuICAgICAgICAgICAgICAgIGlmIChpc0VtcHR5KHggKyBkaXIsIHkgLSAxKSkgeyBtb3ZlKHgsIHksIHggKyBkaXIsIHkgLSAxKTsgdXBkYXRlZFBvc2l0aW9ucy5hZGQoYCR7eCtkaXJ9LCR7eS0xfWApOyByZXR1cm47IH1cclxuICAgICAgICAgICAgICAgIC8vIFNpZGV3YXlzXHJcbiAgICAgICAgICAgICAgICBpZiAoaXNFbXB0eSh4ICsgZGlyLCB5KSkgeyBtb3ZlKHgsIHksIHggKyBkaXIsIHkpOyB1cGRhdGVkUG9zaXRpb25zLmFkZChgJHt4K2Rpcn0sJHt5fWApOyByZXR1cm47IH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBGYWxsaW5nIFBhcnRpY2xlIE1vdmVtZW50IChQb3dkZXJzICYgTGlxdWlkcylcclxuICAgICAgICBlbHNlIGlmIChERU5TSVRJRVNbZWxlbWVudF0gPiBERU5TSVRJRVNbRUxFTUVOVF9UWVBFLkVNUFRZXSAmJiBERU5TSVRJRVNbZWxlbWVudF0gPCBERU5TSVRJRVNbRUxFTUVOVF9UWVBFLldBTExdKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRlbnNpdHkgPSBERU5TSVRJRVNbZWxlbWVudF07XHJcblxyXG4gICAgICAgICAgICAvLyBEb3duXHJcbiAgICAgICAgICAgIGNvbnN0IGJlbG93ID0gZ3JpZFt5ICsgMV0/Llt4XTtcclxuICAgICAgICAgICAgaWYgKGJlbG93ICE9PSB1bmRlZmluZWQgJiYgZGVuc2l0eSA+IERFTlNJVElFU1tiZWxvd10pIHtcclxuICAgICAgICAgICAgICAgIG1vdmUoeCwgeSwgeCwgeSArIDEpOyB1cGRhdGVkUG9zaXRpb25zLmFkZChgJHt4fSwke3krMX1gKTsgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBEaWFnb25hbCBEb3duXHJcbiAgICAgICAgICAgIGNvbnN0IGRpciA9IE1hdGgucmFuZG9tKCkgPCAwLjUgPyAtMSA6IDE7XHJcbiAgICAgICAgICAgIGNvbnN0IGRpYWcxID0gZ3JpZFt5ICsgMV0/Llt4ICsgZGlyXTtcclxuICAgICAgICAgICAgaWYgKGRpYWcxICE9PSB1bmRlZmluZWQgJiYgZGVuc2l0eSA+IERFTlNJVElFU1tkaWFnMV0pIHtcclxuICAgICAgICAgICAgICAgIG1vdmUoeCwgeSwgeCArIGRpciwgeSArIDEpOyB1cGRhdGVkUG9zaXRpb25zLmFkZChgJHt4K2Rpcn0sJHt5KzF9YCk7IHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBkaWFnMiA9IGdyaWRbeSArIDFdPy5beCAtIGRpcl07XHJcbiAgICAgICAgICAgIGlmIChkaWFnMiAhPT0gdW5kZWZpbmVkICYmIGRlbnNpdHkgPiBERU5TSVRJRVNbZGlhZzJdKSB7XHJcbiAgICAgICAgICAgICAgICBtb3ZlKHgsIHksIHggLSBkaXIsIHkgKyAxKTsgdXBkYXRlZFBvc2l0aW9ucy5hZGQoYCR7eC1kaXJ9LCR7eSsxfWApOyByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFNpZGV3YXlzIChMaXF1aWRzIE9ubHkpXHJcbiAgICAgICAgICAgIGlmIChlbGVtZW50ID09PSBFTEVNRU5UX1RZUEUuV0FURVIgfHwgZWxlbWVudCA9PT0gRUxFTUVOVF9UWVBFLkFDSUQgfHwgZWxlbWVudCA9PT0gRUxFTUVOVF9UWVBFLkxBVkEpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGlzU2xvdyA9IChlbGVtZW50ID09PSBFTEVNRU5UX1RZUEUuTEFWQSAmJiBNYXRoLnJhbmRvbSgpIDwgMC41KTtcclxuICAgICAgICAgICAgICAgIGlmICghaXNTbG93KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRW1wdHkoeCArIGRpciwgeSkpIHsgbW92ZSh4LCB5LCB4ICsgZGlyLCB5KTsgdXBkYXRlZFBvc2l0aW9ucy5hZGQoYCR7eCtkaXJ9LCR7eX1gKTsgcmV0dXJuOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRW1wdHkoeCAtIGRpciwgeSkpIHsgbW92ZSh4LCB5LCB4IC0gZGlyLCB5KTsgdXBkYXRlZFBvc2l0aW9ucy5hZGQoYCR7eC1kaXJ9LCR7eX1gKTsgcmV0dXJuOyB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIC0tLSBJbnRlcmFjdGlvbiBQaGFzZSAtLS1cclxuICAgICAgICAvLyBUaGlzIGNvZGUgb25seSBydW5zIGlmIHRoZSBwYXJ0aWNsZSBkaWQgbm90IG1vdmUgaW4gdGhlIG1vdmVtZW50IHBoYXNlLlxyXG4gICAgICAgIHN3aXRjaChlbGVtZW50KSB7XHJcbiAgICAgICAgICAgIGNhc2UgRUxFTUVOVF9UWVBFLkxBVkE6XHJcbiAgICAgICAgICAgIGNhc2UgRUxFTUVOVF9UWVBFLkFDSUQ6XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gLTE7IGkgPD0gMTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IC0xOyBqIDw9IDE7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMCAmJiBqID09PSAwKSBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmVpZ2hib3IgPSBncmlkW3kgKyBqXT8uW3ggKyBpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5laWdoYm9yID09PSB1bmRlZmluZWQgfHwgbmVpZ2hib3IgPT09IEVMRU1FTlRfVFlQRS5XQUxMIHx8IG5laWdoYm9yID09PSBlbGVtZW50KSBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpcyh4ICsgaSwgeSArIGosIEVMRU1FTlRfVFlQRS5MQVZBKSAmJiBlbGVtZW50ID09PSBFTEVNRU5UX1RZUEUuQUNJRCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0KHggKyBpLCB5ICsgaiwgRUxFTUVOVF9UWVBFLlNNT0tFKTsgc2V0KHgsIHksIEVMRU1FTlRfVFlQRS5TTU9LRSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobmVpZ2hib3IgIT09IEVMRU1FTlRfVFlQRS5FTVBUWSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0KHggKyBpLCB5ICsgaiwgRUxFTUVOVF9UWVBFLkZJUkUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQgPT09IEVMRU1FTlRfVFlQRS5BQ0lEICYmIE1hdGgucmFuZG9tKCkgPCAwLjIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXQoeCwgeSwgRUxFTUVOVF9UWVBFLkVNUFRZKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIEVMRU1FTlRfVFlQRS5GSVJFOlxyXG4gICAgICAgICAgICAgICAgaWYgKE1hdGgucmFuZG9tKCkgPCAwLjA1KSB7IHNldCh4LCB5LCBFTEVNRU5UX1RZUEUuSE9UX0FTSCk7IH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIEVMRU1FTlRfVFlQRS5IT1RfQVNIOlxyXG4gICAgICAgICAgICAgICAgaWYgKE1hdGgucmFuZG9tKCkgPCAwLjA1KSB7IHNldCh4LCB5LCBFTEVNRU5UX1RZUEUuQVNIKTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gLTE7IGkgPD0gMTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IC0xOyBqIDw9IDE7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMCAmJiBqID09PSAwKSBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmVpZ2hib3IgPSBncmlkW3kgKyBqXT8uW3ggKyBpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5laWdoYm9yID09PSB1bmRlZmluZWQpIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5laWdoYm9yID09PSBFTEVNRU5UX1RZUEUuV0FURVIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldCh4LCB5LCBFTEVNRU5UX1RZUEUuQVNIKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldCh4ICsgaSwgeSArIGosIEVMRU1FTlRfVFlQRS5TTU9LRSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElnbml0ZSBvdGhlciBmbGFtbWFibGUgdGhpbmdzIChidXQgbm90IGFzaClcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZWlnaGJvciAhPT0gRUxFTUVOVF9UWVBFLkFTSCAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmVpZ2hib3IgIT09IEVMRU1FTlRfVFlQRS5IT1RfQVNIICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBERU5TSVRJRVNbbmVpZ2hib3JdID4gMCAmJiBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIERFTlNJVElFU1tuZWlnaGJvcl0gPCBERU5TSVRJRVNbRUxFTUVOVF9UWVBFLkxBVkFdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKE1hdGgucmFuZG9tKCkgPCAwLjA1KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0KHggKyBpLCB5ICsgaiwgRUxFTUVOVF9UWVBFLkZJUkUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldCh4LCB5LCBFTEVNRU5UX1RZUEUuQVNIKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWduaXRlIG90aGVyIGFzaCAodmVyeSBsb3cgY2hhbmNlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChuZWlnaGJvciA9PT0gRUxFTUVOVF9UWVBFLkFTSCB8fCBuZWlnaGJvciA9PT0gRUxFTUVOVF9UWVBFLkhPVF9BU0gpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChNYXRoLnJhbmRvbSgpIDwgMC4wMDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXQoeCArIGksIHkgKyBqLCBFTEVNRU5UX1RZUEUuRklSRSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0KHgsIHksIEVMRU1FTlRfVFlQRS5BU0gpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgRUxFTUVOVF9UWVBFLlNUT05FX0FTSDpcclxuICAgICAgICAgICAgICAgIGNvbnN0IGlzU3RhYmxlID0gKERFTlNJVElFU1tncmlkW3krMV0/Llt4XV0gPj0gREVOU0lUSUVTW0VMRU1FTlRfVFlQRS5TVE9ORV9BU0hdKTtcclxuICAgICAgICAgICAgICAgIGlmIChpc1N0YWJsZSAmJiBNYXRoLnJhbmRvbSgpIDwgMC4wMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldCh4LCB5LCBFTEVNRU5UX1RZUEUuU1RPTkUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgRUxFTUVOVF9UWVBFLlBMQU5UOlxyXG4gICAgICAgICAgICAgICAgIGlmIChNYXRoLnJhbmRvbSgpIDwgMC4wNSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAtMTsgaSA8PSAxOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IC0xOyBqIDw9IDE7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzKHggKyBpLCB5ICsgaiwgRUxFTUVOVF9UWVBFLldBVEVSKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJ5IHRvIGdyb3cgaW50byBhbiBlbXB0eSBzcGFjZSBuZWFyYnlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGdyb3dYID0geCAtIGk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBncm93WSA9IHkgLSBqO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRW1wdHkoZ3Jvd1gsIGdyb3dZKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldChncm93WCwgZ3Jvd1ksIEVMRU1FTlRfVFlQRS5QTEFOVCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBFTEVNRU5UX1RZUEUuU01PS0U6XHJcbiAgICAgICAgICAgICAgICAvLyBJZiBzbW9rZSBpcyBzdHVjaywgaXQgaGFzIGEgY2hhbmNlIHRvIGRpc2FwcGVhci5cclxuICAgICAgICAgICAgICAgIGlmIChNYXRoLnJhbmRvbSgpIDwgMC4wMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldCh4LCB5LCBFTEVNRU5UX1RZUEUuRU1QVFkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB1cGRhdGVkUG9zaXRpb25zLmFkZChwb3MpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCB0aGUgZ3JpZCBhbmQgdXBkYXRlIGVsZW1lbnRzXHJcbiAgICBmb3IgKGxldCB5ID0gaGVpZ2h0IC0gMTsgeSA+PSAwOyB5LS0pIHtcclxuICAgICAgICBjb25zdCBzY2FuRGlyZWN0aW9uID0gTWF0aC5yYW5kb20oKSA8IDAuNSA/IDEgOiAtMTtcclxuICAgICAgICBpZiAoc2NhbkRpcmVjdGlvbiA9PT0gMSkge1xyXG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHdpZHRoOyB4KyspIHtcclxuICAgICAgICAgICAgICAgIHVwZGF0ZUVsZW1lbnQoeCwgeSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gd2lkdGggLSAxOyB4ID49IDA7IHgtLSkge1xyXG4gICAgICAgICAgICAgICAgdXBkYXRlRWxlbWVudCh4LCB5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBQcm9jZXNzIHNvbGlkcyAobm9uLW1vdmluZyBidXQgaW50ZXJhY3RpdmUgZWxlbWVudHMpXHJcbiAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGhlaWdodDsgeSsrKSB7XHJcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB3aWR0aDsgeCsrKSB7XHJcbiAgICAgICAgICAgICBpZiAoZ3JpZFt5XVt4XSA9PT0gRUxFTUVOVF9UWVBFLlBMQU5UKSB7XHJcbiAgICAgICAgICAgICAgICAgdXBkYXRlRWxlbWVudCh4LCB5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBJdGVyYXRlIHRvcC10by1ib3R0b20gZm9yIHJpc2luZyBwYXJ0aWNsZXNcclxuICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHtcclxuICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHdpZHRoOyB4KyspIHtcclxuICAgICAgICAgICAgIGlmIChncmlkW3ldW3hdID09PSBFTEVNRU5UX1RZUEUuU01PS0UgfHwgZ3JpZFt5XVt4XSA9PT0gRUxFTUVOVF9UWVBFLkZJUkUpIHtcclxuICAgICAgICAgICAgICAgICB1cGRhdGVFbGVtZW50KHgsIHkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59OyAiXSwibmFtZXMiOlsiRUxFTUVOVF9UWVBFIiwiRU1QVFkiLCJXQUxMIiwiU0FORCIsIldBVEVSIiwiUExBTlQiLCJGSVJFIiwiTEFWQSIsIkFDSUQiLCJTTU9LRSIsIlNUT05FIiwiU1RPTkVfQVNIIiwiQVNIIiwiSE9UX0FTSCIsIkVMRU1FTlRfQ09MT1JTIiwiREVOU0lUSUVTIiwiSW5maW5pdHkiLCJMT0NBTF9TVE9SQUdFX0tFWSIsIkNFTExfU0laRSIsIndpZHRoIiwiaGVpZ2h0IiwiZ3JpZCIsImFyZVdhbGxzT24iLCJzZXRXYWxscyIsImVuYWJsZWQiLCJ3YWxsVHlwZSIsInkiLCJ4Iiwic2F2ZVdvcmxkIiwibG9jYWxTdG9yYWdlIiwic2V0SXRlbSIsIkpTT04iLCJzdHJpbmdpZnkiLCJjbGVhciIsInJlbW92ZUl0ZW0iLCJpbml0IiwiY2FudmFzV2lkdGgiLCJjYW52YXNIZWlnaHQiLCJNYXRoIiwiZmxvb3IiLCJzYXZlZEdyaWQiLCJnZXRJdGVtIiwicGFyc2VkR3JpZCIsInBhcnNlIiwibGVuZ3RoIiwiZSIsImNvbnNvbGUiLCJlcnJvciIsIkFycmF5IiwiZmlsbCIsIm1hcCIsImdldEdyaWQiLCJnZXRDZWxsU2l6ZSIsInNldEVsZW1lbnQiLCJlbGVtZW50VHlwZSIsImJydXNoU2l6ZSIsInJhZGl1cyIsImkiLCJqIiwibmV3WCIsIm5ld1kiLCJtb3ZlIiwieDEiLCJ5MSIsIngyIiwieTIiLCJ0ZW1wIiwiaXNXaXRoaW5Cb3VuZHMiLCJpc0VtcHR5IiwiaXMiLCJzZXQiLCJ1cGRhdGUiLCJ1cGRhdGVkUG9zaXRpb25zIiwiU2V0IiwidXBkYXRlRWxlbWVudCIsInBvcyIsImhhcyIsImVsZW1lbnQiLCJyYW5kb20iLCJkaXIiLCJhZGQiLCJkZW5zaXR5IiwiYmVsb3ciLCJ1bmRlZmluZWQiLCJkaWFnMSIsImRpYWcyIiwiaXNTbG93IiwibmVpZ2hib3IiLCJpc1N0YWJsZSIsImdyb3dYIiwiZ3Jvd1kiLCJzY2FuRGlyZWN0aW9uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/simulation/world.ts\n"));

/***/ })

});